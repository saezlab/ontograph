{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to OntoGraph","text":"<p>OntoGraph is a Python package for programmatic access, navigation, and analysis of biomedical ontologies. It provides a unified interface to download, load, and query ontologies from the OBO Foundry and other sources, supporting both OBO and OWL formats.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Ontology Catalog Access   Browse and retrieve metadata for hundreds of ontologies from the OBO Foundry registry.</p> </li> <li> <p>Flexible Ontology Loading   Load ontologies from local files, remote URLs, or directly from the OBO Foundry catalog.</p> </li> <li> <p>Graph Navigation &amp; Querying   Traverse ontology graphs: get parents, children, ancestors, descendants, siblings, and roots of terms.</p> </li> <li> <p>Relationship Analysis   Check ancestor/descendant/sibling relationships, find common and lowest common ancestors, and compute distances between terms.</p> </li> <li> <p>Introspection Utilities   Analyze ontology structure, calculate paths and trajectories, and visualize term hierarchies.</p> </li> <li> <p>Caching &amp; Download Management   Efficiently download and cache ontology files for offline use.</p> </li> </ul>"},{"location":"#main-components","title":"Main Components","text":"<ul> <li> <p>ClientCatalog   Interact with the ontology catalog: list available ontologies, retrieve metadata, and explore catalog structure.</p> </li> <li> <p>ClientOntology   Load and query individual ontologies: navigate term relationships, analyze graph structure, and perform advanced queries.</p> </li> <li> <p>Loader &amp; Downloader Modules   Abstract and concrete classes for loading ontologies and managing downloads from various sources.</p> </li> <li> <p>Query Adapters   Modular classes for navigation (<code>OntologyNavigator</code>), relationship analysis (<code>OntologyRelations</code>), and introspection (<code>OntologyIntrospection</code>).</p> </li> </ul>"},{"location":"#why-ontograph","title":"Why OntoGraph?","text":"<ul> <li>Unified and extensible API for ontology operations</li> <li>Designed for both interactive exploration and programmatic workflows</li> <li>Built-in support for caching and efficient data management</li> <li>Modular architecture for easy integration and extension</li> </ul> <p>Explore, analyze, and integrate ontologies with ease using OntoGraph!</p>"},{"location":"about/","title":"About","text":"<p>This project was created by Saezlab and Scientifc Software Center.</p>"},{"location":"installation/","title":"Installation guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing <code>ontograph</code>, please ensure you have the following tools installed:</p> Tool Minimum Version Description Installation Guide Python 3.10 Programming language Install Python 3 uv \u2014 Python packaging &amp; dependency manager Install uv git \u2014 Version control system Install git <p>Tip</p> <p>If you are missing any of those pre-requisites, please follow the installation guide in each resource before you continue.</p>"},{"location":"installation/#checking-prerequisites","title":"Checking prerequisites","text":"<p>Verify that everything is installed by running:</p> <pre><code>python --version   # Should be 3.10 or higher\nuv --version\ngit --version\n</code></pre>"},{"location":"installation/#installation","title":"Installation","text":"<p>This package is currently under development. To try it out, you can clone the repository and install it in \"editable\" mode. This allows you to make changes to the code and have them reflected immediately without reinstalling.</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/saezlab/ontograph.git\n</code></pre></p> </li> <li> <p>Navigate into the project directory: <pre><code>cd ontograph\n</code></pre></p> </li> <li> <p>Install the package in editable mode using <code>uv</code>: <pre><code>uv pip install -e .\n</code></pre></p> </li> </ol> <p>You can now start using <code>ontograph</code> in your Python environment. Any changes you make to the source code will take effect immediately.</p>"},{"location":"community/","title":"Join Us","text":"<p>Welcome to the ontograph community! We follow open-source principles and encourage any sort of contribution. We communicate on GitHub, where we also organise our projects.</p> <p>Please review our Code of Conduct before participating in issues, discussions, and pull requests.</p> <ul> <li> <p> Where to Start</p> <p>If you'd like to learn how to contribute to our projects, please follow the steps outlined in the contribution guide.</p> <p> To the contribution guide</p> </li> </ul>"},{"location":"community/#contributing-guidelines-github-links","title":"Contributing Guidelines GitHub Links","text":"<ul> <li>Contribution guidelines (coming soon in this docs section)</li> <li>Code of Conduct</li> </ul>"},{"location":"community/contribute-codebase/","title":"Developer Guide","text":"<p>Thank you for considering to contribute to the project! This guide will help you to get started with the development of the project. If you have any questions, please feel free to ask them in the issue tracker on GitHub.</p>"},{"location":"community/contribute-codebase/#small-contributions","title":"Small Contributions","text":"<p>If you want to contribute a small change (e.g., a bugfix), you can probably immediately go ahead and create a pull request. For more substantial changes or additions, please read on.</p>"},{"location":"community/contribute-codebase/#larger-contributions","title":"Larger Contributions","text":"<p>If you want to contribute a larger change, please create an issue first. This will allow us to discuss the change and make sure that it fits into the project.  It can happen that development for a feature is already in progress, so it is important to check first to avoid duplicate work. If you have any questions, feel free to approach us in any way you like.</p>"},{"location":"community/contribute-codebase/#dependency-management","title":"Dependency management","text":"<p>We use Poetry for dependency management. Please make sure that you have installed Poetry and set up the environment correctly before starting development.</p>"},{"location":"community/contribute-codebase/#setting-up-the-environment","title":"Setting up the environment","text":"<ul> <li> <p>Install dependencies from the lock file: <code>poetry install</code></p> </li> <li> <p>Use the environment: You can either run commands directly with <code>poetry run &lt;command&gt;</code> or open a shell with <code>poetry shell</code> and then run commands directly.</p> </li> </ul>"},{"location":"community/contribute-codebase/#updating-the-environment","title":"Updating the environment","text":"<p>If you want to fix dependency issues, please do so in the Poetry framework. If Poetry does not work for you for some reason, please let us know.</p> <p>The Poetry dependencies are organized in groups. There are groups with dependencies needed for running ontograph (<code>[tool.poetry.dependencies]</code> with the group name <code>main</code>) and a group with dependencies needed for development (<code>[tool.poetry.group.dev.dependencies]</code> with the group name <code>dev</code>).</p> <p>For adding new dependencies:</p> <ul> <li> <p>Add new dependencies via <code>poetry add</code>: <code>poetry add &lt;dependency&gt; --group &lt;group&gt;</code>. This will update the <code>pyproject.toml</code> and lock file automatically.</p> </li> <li> <p>Add new dependencies via <code>pyproject.toml</code>: Add the dependency to the <code>pyproject.toml</code> file in the correct group, including version. Then update the lock file: <code>poetry lock</code> and install the dependencies: <code>poetry install</code>.</p> </li> </ul>"},{"location":"community/contribute-codebase/#code-quality-and-formal-requirements","title":"Code quality and formal requirements","text":"<p>For ensuring code quality, the following tools are used:</p> <ul> <li> <p>isort for sorting imports</p> </li> <li> <p>black for automated code formatting</p> </li> <li> <p>pre-commit-hooks for ensuring some general rules</p> </li> <li> <p>pep585-upgrade for automatically upgrading type hints to the new native types defined in PEP 585</p> </li> <li> <p>pygrep-hooks for ensuring some general naming rules</p> </li> <li> <p>Ruff An extremely fast Python linter and code formatter, written in Rust</p> </li> </ul> <p>We recommend configuring your IDE to execute Ruff on save/type, which will automatically keep your code clean and fix some linting errors as you type. This is made possible by the fast execution of Ruff and removes the need to run a dedicated pre-commit step. For instance, in VSCode or Cursor, you can add this to your <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"editor.formatOnType\": true,\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll.ruff\": \"explicit\",\n        \"source.organizeImports.ruff\": \"explicit\"\n    },\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\"\n}\n</code></pre> <p>Alternatively, pre-commit hooks can be used to automatically or manually run these tools before each commit. They are defined in <code>.pre-commit-config.yaml</code>. To install the hooks run <code>poetry run pre-commit install</code>. The hooks are then executed before each commit. For running the hook for all project files (not only the changed ones) run <code>poetry run pre-commit run --all-files</code>. Our CI runs the pre-commit hooks, so running them locally is a good way to check if your code conforms to the formatting rules.</p>"},{"location":"community/contribute-codebase/#testing","title":"Testing","text":"<p>The project uses pytest for testing. To run the tests, please run <code>pytest</code> in the root directory of the project. We are developing ontograph using test-driven development. Please make sure that you add tests for your code before submitting a pull request.</p> <p>The existing tests can also help you to understand how the code works. If you have any questions, please feel free to ask them in the issue tracker or on Zulip.</p> <p>Before submitting a pull request, please make sure that all tests pass and that the documentation builds correctly.</p>"},{"location":"community/contribute-codebase/#versioning","title":"Versioning","text":"<p>We use semantic versioning for the project. This means that the version number is incremented according to the following scheme:</p> <ul> <li> <p>Increment the major version number if you make incompatible API changes.</p> </li> <li> <p>Increment the minor version number if you add functionality in a backwards-   compatible manner. Since we are still in the 0.x.y version range, most of the   significant changes will increase the minor version number.</p> </li> <li> <p>Increment the patch version number if you make backwards-compatible bug fixes.</p> </li> </ul> <p>We use the <code>bumpversion</code> tool to update the version number in the <code>pyproject.toml</code> file. This will create a new git tag automatically. Usually, versioning is done by the maintainers, so please do not increment versions in pull requests by default.</p>"},{"location":"community/contribute-codebase/#finding-an-issue-to-contribute-to","title":"Finding an issue to contribute to","text":"<p>If you are brand new to ontograph or open-source development, we recommend searching the GitHub \"Issues\" tab to find issues that interest you. Unassigned issues labeled <code>Docs</code> and <code>good first</code> are typically good for newer contributors.</p> <p>Once you've found an interesting issue, it's a good idea to assign the issue to yourself, so nobody else duplicates the work on it.</p> <p>If for whatever reason you are not able to continue working with the issue, please unassign it, so other people know it's available again. If you want to work on an issue that is currently assigned but you're unsure whether work is actually being done, feel free to kindly ask the current assignee if you can take over (please allow at least a week of inactivity before getting in touch).</p>"},{"location":"community/contribute-codebase/#submitting-a-pull-request","title":"Submitting a Pull Request","text":""},{"location":"community/contribute-codebase/#tips-for-a-successful-pull-request","title":"Tips for a successful pull request","text":"<p>To improve the chances of your pull request being reviewed, you should:</p> <ul> <li>Reference an open issue for non-trivial changes to clarify the PR's purpose.</li> <li>Ensure you have appropriate tests. Tests should be the focus of any PR (apart from documentation changes).</li> <li>Keep your pull requests as simple as possible. Larger PRs take longer to review.</li> <li>Ensure that CI is in a green state. Reviewers may tell you to fix the CI before looking at anything else.</li> </ul>"},{"location":"community/contribute-codebase/#version-control-git-and-github","title":"Version control, Git, and GitHub","text":"<p>ontograph is hosted on GitHub, and to contribute, you will need to sign up for a free GitHub account. We use Git for version control to allow many people to work together on the project.</p> <p>If you are new to Git, you can reference some of these resources for learning Git. Feel free to reach out to the contributor community for help if needed:</p> <ul> <li>Git documentation.</li> </ul> <p>The project follows a forking workflow further described on this page whereby contributors fork the repository, make changes and then create a Pull Request. So please be sure to read and follow all the instructions in this guide.</p> <p>If you are new to contributing to projects through forking on GitHub, take a look at the GitHub documentation for contributing to projects. GitHub provides a quick tutorial using a test repository that may help you become more familiar with forking a repository, cloning a fork, creating a feature branch, pushing changes and making Pull Requests.</p> <p>Below are some useful resources for learning more about forking and Pull Requests on GitHub:</p> <ul> <li> <p>the GitHub documentation for forking a repo.</p> </li> <li> <p>the GitHub documentation for collaborating with Pull Requests.</p> </li> <li> <p>the GitHub documentation for working with forks.</p> </li> </ul> <p>There are also many unwritten rules and conventions that are helpful in interacting with other open-source contributors. These lessons from PyOpenSci are a good resource for learning more about how to interact with other open-source contributors in scientific computing.</p>"},{"location":"community/contribute-codebase/#getting-started-with-git","title":"Getting started with Git","text":"<p>GitHub has instructions for installing git, setting up your SSH key, and configuring git. All these steps need to be completed before you can work seamlessly between your local repository and GitHub.</p>"},{"location":"community/contribute-codebase/#create-a-fork-of-ontograph","title":"Create a fork of ontograph","text":"<p>You will need your own fork of ontographin order to eventually open a Pull Request. Go to the ontograph project page and hit the Fork button. Please uncheck the box to copy only the main branch before selecting Create Fork. You will then want to clone your fork to your machine.</p> <pre><code>git clone https://github.com/your-user-name/ontograph.git\ncd ontograph\ngit remote add upstream https://github.com/ontograph/ontograph.git\ngit fetch upstream\n</code></pre> <p>This creates the directory <code>ontograph</code> and connects your repository to the upstream (main project) ontograph repository. They have the same name, but your local repository and fork are separate from the upstream repository.</p>"},{"location":"community/contribute-codebase/#creating-a-feature-branch","title":"Creating a feature branch","text":"<p>Your local <code>main</code> branch should always reflect the current state of ontograph repository. First ensure it's up-to-date with the main ontograph repository.</p> <pre><code>git checkout main\ngit pull upstream main --ff-only\n</code></pre> <p>Then, create a feature branch for making your changes. For example, we are going to create a branch called <code>my-new-feature-for-ontograph</code></p> <pre><code>git checkout -b my-new-feature-for-ontograph\n</code></pre> <p>This changes your working branch from <code>main</code> to the <code>my-new-feature-for-ontograph</code> branch. Keep any changes in this branch specific to one bug or feature so it is clear what the branch brings to ontograph. You can have many feature branches and switch between them using the <code>git checkout</code> command.</p>"},{"location":"community/contribute-codebase/#making-code-changes","title":"Making code changes","text":"<p>Before modifying any code, ensure you follow the contributing environment guidelines to set up an appropriate development environment.</p> <p>When making changes, follow these ontograph-specific guidelines:</p> <ol> <li> <p>Keep changes of that branch/PR focused on a single feature or bug fix.</p> </li> <li> <p>Follow roughly the conventional commit message conventions.</p> </li> </ol>"},{"location":"community/contribute-codebase/#pushing-your-changes","title":"Pushing your changes","text":"<p>When you want your committed changes to appear publicly on your GitHub page, you can push your forked feature branch's commits to your forked repository on GitHub.</p> <p>Now your code is on GitHub, but it is not yet a part of the ontograph project. For that to happen, a Pull Request (PR) needs to be submitted.</p>"},{"location":"community/contribute-codebase/#opening-a-pull-request-pr","title":"Opening a Pull Request (PR)","text":"<p>If everything looks good according to the general guidelines, you are ready to make a Pull Request. A Pull Request is how code from your fork becomes available to the project maintainers to review and merge into the project to appear in the next release. To submit a Pull Request:</p> <ol> <li> <p>Navigate to your repository on GitHub.</p> </li> <li> <p>Click on the Compare &amp; Pull Request button.</p> </li> <li> <p>You can then click on Commits and Files Changed to make sure everything looks okay one last time.</p> </li> <li> <p>Write a descriptive title that includes prefixes. ontograph uses a convention for title prefixes, most commonly, <code>feat:</code> for features, <code>fix:</code> for bug fixes, and <code>refactor:</code> for refactoring.</p> </li> <li> <p>Write a description of your changes in the <code>Preview Discussion</code> tab. This description will inform the reviewers about the changes you made, so please include all relevant information, including the motivation, implementation details, and references to any issues that you are addressing.</p> </li> <li> <p>Make sure to <code>Allow edits from maintainers</code>; this allows the maintainers to make changes to your PR directly, which is useful if you are not sure how to fix the PR.</p> </li> <li> <p>Click <code>Send Pull Request</code>.</p> </li> <li> <p>Optionally, you can assign reviewers to your PR, if you know who should review it.</p> </li> </ol> <p>This request then goes to the repository maintainers, and they will review the code.</p>"},{"location":"community/contribute-codebase/#updating-your-pull-request","title":"Updating your Pull Request","text":"<p>Based on the review you get on your pull request, you will probably need to make some changes to the code. You can follow the steps above again to address any feedback and update your pull request.</p>"},{"location":"community/contribute-codebase/#parallel-changes-in-the-upstream-main-branch","title":"Parallel changes in the upstream <code>main</code> branch","text":"<p>In case of simultaneous changes to the upstream code, it is important that these changes are reflected in your pull request. To update your feature branch with changes in the ontograph <code>main</code> branch, run:</p> <pre><code>    git checkout my-new-feature-for-ontograph\n    git fetch upstream\n    git merge upstream/main\n</code></pre> <p>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</p> <p>If there are merge conflicts, you need to resolve those conflicts. See here for an explanation on how to do this.</p> <p>Once the conflicts are resolved, run:</p> <ol> <li><code>git add -u</code> to stage any files you've updated;</li> <li><code>git commit</code> to finish the merge.</li> </ol> <p>After the feature branch has been updated locally, you can now update your pull request by pushing to the branch on GitHub:</p> <pre><code>    git push origin my-new-feature-for-ontograph\n</code></pre> <p>Any <code>git push</code> will automatically update your pull request with your branch's changes and restart the <code>Continuous Integration</code> checks.</p>"},{"location":"community/contribute-docs/","title":"Contributing to the documentation","text":"<p>Contributing to the documentation benefits everyone who uses ontograph. We encourage you to help us improve the documentation, and you don't have to be an expert on ontograph to do so! In fact, there are sections of the docs that are worse off after being written by experts. If something in the docs doesn't make sense to you, updating the relevant section after you figure it out is a great way to ensure it will help the next person.</p>"},{"location":"community/contribute-docs/#how-to-contribute-to-the-documentation","title":"How to contribute to the documentation","text":"<p>The documentation is written in Markdown, which is almost like writing in plain English, and built using Material for MkDocs. The simplest way to contribute to the docs is to click on the <code>Edit</code> button (pen and paper) at the top right of any page. This will take you to the source file on GitHub, where you can make your changes and create a pull request using GitHub's web interface (the <code>Commit changes...</code> button).</p> <p>Some other important things to know about the docs:</p> <ul> <li> <p>The ontograph documentation consists of two parts: the docstrings in the code   itself and the docs in the <code>docs/</code> folder. The docstrings provide a clear   explanation of the usage of the individual functions, while the documentation   website you are looking at is built from the <code>docs/</code> folder.</p> </li> <li> <p>The docstrings follow a convention, based on the Google Docstring   Standard.</p> </li> <li> <p>Our API documentation files in <code>docs/reference/source</code> contain the   instructions for the auto-generated documentation from the docstrings. For   classes, there are a few subtleties around controlling which methods and   attributes have pages auto-generated.</p> </li> </ul>"},{"location":"community/contribute/","title":"How to Start Contributing","text":"<p>There are many valuable ways to contribute besides writing code. Thank you for dedicating your time to improve our project!</p>"},{"location":"community/contribute/#bug-reports-and-enhancement-requests","title":"Bug reports and enhancement requests","text":"<p>Bug reports and enhancement requests are an important part of making any software more stable. We curate them though Github issues. When opening an issue or request, please select the appropriate category and fill out the issue form fully to ensure others and the core development team can fully understand the scope of the issue. If your category is not listed, you can create a blank issue.</p> <p>The issue will then show up to the ontograph community and be open to comments/ideas from others.</p>"},{"location":"community/contribute/#categories","title":"Categories","text":"<ul> <li>Bug Report: Report incorrect behavior in the ontograph library</li> <li>Register New Component: Register a new component in the ontograph ecosystem, either one you have created, or one that you would like to see added</li> <li>Documentation Improvement: Report wrong or missing documentation</li> <li>Feature Request: Suggest an idea for ontograph</li> </ul>"},{"location":"community/contribute/#detailed-guides","title":"Detailed Guides","text":"<ul> <li> <p> Contributing to the Documentation</p> <p>A simple way to get started is to contribute to the documentation. Please follow the guide here to learn how to do so.</p> <p> To the contribution guide</p> </li> </ul> <ul> <li> <p> Contributing to the Code Base</p> <p>The best way to contribute code is to open a pull request on Github. Please follow the guide here to learn how to do so.</p> <p> To the contribution guide</p> </li> </ul>"},{"location":"learn/tutorials/quickstart/","title":"Quickstart","text":"<p>Welcome to the OntoGraph Quickstart! This guide will help you get up and running with OntoGraph, showing you how to explore ontology catalogs and interact with ontologies programmatically.</p>"},{"location":"learn/tutorials/quickstart/#1-explore-the-obo-foundry-catalog","title":"1. Explore the OBO Foundry Catalog","text":"<p>First, let's interact with the OBO Foundry catalog to discover available ontologies.</p> <pre><code>from ontograph.client import ClientCatalog\n\n# Create a catalog client (specify a cache directory for downloads)\nclient_catalog = ClientCatalog(cache_dir=\"./data/out\")\n\n# Load the catalog (downloads if not cached)\nclient_catalog.load_catalog()\n</code></pre>"},{"location":"learn/tutorials/quickstart/#list-available-ontologies","title":"List Available Ontologies","text":"<pre><code># Get a list of ontologies (as dicts with id and title)\nontologies_list = client_catalog.list_available_ontologies()\nprint(ontologies_list[:3])  # Show the first three\n</code></pre>"},{"location":"learn/tutorials/quickstart/#print-ontology-list","title":"Print Ontology List","text":"<pre><code>client_catalog.print_available_ontologies()\n</code></pre>"},{"location":"learn/tutorials/quickstart/#get-metadata-for-a-specific-ontology","title":"Get Metadata for a Specific Ontology","text":"<pre><code># Show metadata for the Gene Ontology (GO)\nmetadata_go = client_catalog.get_ontology_metadata(ontology_id=\"go\", show_metadata=True)\n</code></pre>"},{"location":"learn/tutorials/quickstart/#2-load-and-explore-an-ontology","title":"2. Load and Explore an Ontology","text":"<p>Now, let's load an ontology and explore its structure.</p> <pre><code>from ontograph.client import ClientOntology\n\n# Create an ontology client\nclient_ontology = ClientOntology(cache_dir=\"./data/out\")\n\n# Load a sample ontology (provided in the repo for testing)\nclient_ontology.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n</code></pre>"},{"location":"learn/tutorials/quickstart/#3-visualize-the-ontology-structure","title":"3. Visualize the Ontology Structure","text":"<p>The included demo ontology has the following structure (Z is the root):</p> <pre><code>graph TB\n    Z((Z)) --&gt; A((A))\n    Z((Z)) --&gt; B((B))\n    Z((Z)) --&gt; C((C))\n    A((A)) --&gt; D((D))\n    B((B)) --&gt; H((H))\n    B((B)) --&gt; I((I))\n    C((C)) --&gt; J((J))\n    D((D)) --&gt; E((E))\n    D((D)) --&gt; F((F))\n    D((D)) --&gt; G((G))\n    H((H)) --&gt; K((K))\n    I((I)) --&gt; L((L))\n    J((J)) --&gt; M((M))\n    E((E)) --&gt; N((N))\n    F((F)) --&gt; O((O))\n    F((F)) --&gt; Y((Y))\n    G((G)) --&gt; K1((K1))\n    G((G)) --&gt; K2((K2))\n    K((K)) --&gt; Q((Q))\n    K((K)) --&gt; G1((G))\n    M((M)) --&gt; S((S))\n    G1((G)) --&gt; K11((K1))\n    G1((G)) --&gt; K21((K2))\n    S((S)) --&gt; T((T))\n    T((T)) --&gt; U((U))\n    U((T)) --&gt; V((V))\n    U((U)) --&gt; W((W))\n    W((W)) --&gt; Y1((Y))</code></pre>"},{"location":"learn/tutorials/quickstart/#4-common-ontology-queries","title":"4. Common Ontology Queries","text":""},{"location":"learn/tutorials/quickstart/#navigation","title":"Navigation","text":"<ul> <li>Get ancestors: <pre><code>client_ontology.get_ancestors(term_id=\"S\")\n</code></pre></li> <li>Ancestors with distance: <pre><code>list(client_ontology.get_ancestors_with_distance(term_id=\"S\"))\n</code></pre></li> <li>Get children: <pre><code>client_ontology.get_children(term_id=\"A\")\n</code></pre></li> <li>Get descendants: <pre><code>client_ontology.get_descendants(term_id=\"U\")\n</code></pre></li> <li>Descendants with distance: <pre><code>list(client_ontology.get_descendants_with_distance(term_id=\"U\"))\n</code></pre></li> <li>Get parents: <pre><code>client_ontology.get_parents(term_id=\"U\")\n</code></pre></li> <li>Get root node: <pre><code>client_ontology.get_root()\n</code></pre></li> <li>Get siblings: <pre><code>client_ontology.get_siblings(term_id=\"K1\")\n</code></pre></li> <li>Get a term: <pre><code>client_ontology.get_term(term_id=\"E\")\n</code></pre></li> </ul>"},{"location":"learn/tutorials/quickstart/#relations","title":"Relations","text":"<ul> <li>Common ancestors: <pre><code>client_ontology.get_common_ancestors(node_ids=[\"K\", \"L\"])\n</code></pre></li> <li>Lowest common ancestors: <pre><code>client_ontology.get_lowest_common_ancestors(node_ids=[\"K\", \"L\"])\n</code></pre></li> <li>Is ancestor: <pre><code>client_ontology.is_ancestor(ancestor_node=\"A\", descendant_node=\"N\")\n</code></pre></li> <li>Is descendant: <pre><code>client_ontology.is_descendant(descendant_node=\"A\", ancestor_node=\"N\")\n</code></pre></li> <li>Is sibling: <pre><code>client_ontology.is_sibling(nodeA=\"F\", nodeB=\"G\")\n</code></pre></li> </ul>"},{"location":"learn/tutorials/quickstart/#introspection","title":"Introspection","text":"<ul> <li>Distance from root: <pre><code>client_ontology.get_distance_from_root(term_id=\"V\")\n</code></pre></li> <li>Path between nodes: <pre><code>client_ontology.get_path_between(nodeA=\"Q\", nodeB=\"B\")\n</code></pre></li> <li>All trajectories from root: <pre><code>trajectories = client_ontology.get_trajectories_from_root(term_id=\"Y\")\n</code></pre></li> <li>Print trajectories tree: <pre><code>client_ontology.print_term_trajectories_tree(trajectories)\n</code></pre></li> </ul>"},{"location":"learn/tutorials/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for more details.</li> <li>Try loading your own ontology files or experiment with different queries!</li> </ul> <p>_OntoGraph makes ontology exploration and analysis simple and powerful.</p>"},{"location":"reference/source/ontograph/client-catalog/","title":"ClientCatalog","text":"<p><code>ClientCatalog</code> is the main interface for interacting with the ontology catalog in OntoGraph. It allows you to load the catalog, list available ontologies, retrieve metadata, and access download URLs and formats.</p> <p>This class is ideal for users who want to explore the catalog of available ontologies, inspect their metadata, and prepare for ontology loading and analysis.</p>"},{"location":"reference/source/ontograph/client-catalog/#features","title":"Features","text":"<ul> <li>Load and cache the ontology catalog from OBO Foundry</li> <li>List all available ontologies and their metadata</li> <li>Retrieve metadata for a specific ontology</li> <li>Get download URLs and available formats for each ontology</li> <li>Print the catalog schema tree for exploration</li> </ul>"},{"location":"reference/source/ontograph/client-catalog/#api-reference","title":"API Reference","text":"<p>Client for interacting with the ontology catalog.</p> <p>Allows loading the catalog, listing available ontologies, and retrieving metadata.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() catalog.list_available_ontologies()[0]</p> Source code in <code>ontograph/client.py</code> <pre><code>class ClientCatalog:\n    \"\"\"Client for interacting with the ontology catalog.\n\n    Allows loading the catalog, listing available ontologies, and retrieving metadata.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; catalog.list_available_ontologies()[0]\n        {'id': 'ado', 'title': \"Alzheimer's Disease Ontology\"}\n    \"\"\"\n\n    def __init__(self, cache_dir: str = DEFAULT_CACHE_DIR) -&gt; None:\n        \"\"\"Initialize the ClientCatalog.\n\n        Args:\n            cache_dir (str, optional): Directory for caching catalog data. Defaults to DEFAULT_CACHE_DIR.\n        \"\"\"\n        self.__catalog_adapter = CatalogOntologies(cache_dir=Path(cache_dir))\n\n    def load_catalog(self, force_download: bool = False) -&gt; None:\n        \"\"\"Load the ontology catalog.\n\n        Args:\n            force_download (bool, optional): Force download of catalog data. Defaults to False.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n        \"\"\"\n        return self.__catalog_adapter.load_catalog(\n            force_download=force_download\n        )\n\n    def catalog_as_dict(self) -&gt; dict:\n        \"\"\"Retrieve the ontology catalog as a dictionary.\n\n        Returns:\n            dict: The ontology catalog.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n            &gt;&gt;&gt; isinstance(catalog.catalog_as_dict(), dict)\n            True\n        \"\"\"\n        return self.__catalog_adapter.catalog\n\n    def list_available_ontologies(self) -&gt; list[dict]:\n        \"\"\"List all available ontologies in the catalog.\n\n        Returns:\n            list[dict]: List of ontology metadata dictionaries.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n            &gt;&gt;&gt; isinstance(catalog.list_available_ontologies(), list)\n            True\n        \"\"\"\n        return self.__catalog_adapter.list_available_ontologies()\n\n    def print_available_ontologies(self) -&gt; None:\n        \"\"\"Print all available ontologies in the catalog.\n\n        Example:\n            - catalog = ClientCatalog()\n            - catalog.load_catalog()\n            - catalog.print_available_ontologies()\n        \"\"\"\n        return self.__catalog_adapter.print_available_ontologies()\n\n    def print_catalog_schema_tree(self) -&gt; None:\n        \"\"\"Print the schema tree of the ontology catalog.\n\n        Example:\n            - catalog = ClientCatalog()\n            - catalog.print_catalog_schema_tree()\n        \"\"\"\n        self.__catalog_adapter.print_catalog_schema_tree()\n\n    def get_ontology_metadata(\n        self, ontology_id: str, show_metadata: bool = False\n    ) -&gt; dict:\n        \"\"\"Retrieve metadata for a specific ontology.\n\n        Args:\n            ontology_id (str): Ontology identifier.\n            show_metadata (bool, optional): Include detailed metadata. Defaults to False.\n\n        Returns:\n            dict: Metadata for the specified ontology.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n            &gt;&gt;&gt; meta = catalog.get_ontology_metadata('go')\n            &gt;&gt;&gt; isinstance(meta, dict)\n            True\n        \"\"\"\n        return self.__catalog_adapter.get_ontology_metadata(\n            ontology_id, show_metadata=show_metadata\n        )\n\n    def get_download_url(self, ontology_id: str, format: str = 'obo') -&gt; str:\n        \"\"\"Retrieve the download URL for a specific ontology and format.\n\n        Args:\n            ontology_id (str): Ontology identifier.\n            format (str, optional): Format (e.g., 'obo', 'json'). Defaults to 'obo'.\n\n        Returns:\n            str: Download URL.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n            &gt;&gt;&gt; url = catalog.get_download_url('go')\n            &gt;&gt;&gt; isinstance(url, str)\n            True\n        \"\"\"\n        return self.__catalog_adapter.get_download_url(ontology_id, format)\n\n    def get_available_formats(self, ontology_id: str) -&gt; list[str]:\n        \"\"\"Retrieve available formats for a given ontology.\n\n        Args:\n            ontology_id (str): Ontology identifier.\n\n        Returns:\n            list[str]: Available formats.\n\n        Example:\n            &gt;&gt;&gt; catalog = ClientCatalog()\n            &gt;&gt;&gt; catalog.load_catalog()\n            &gt;&gt;&gt; formats = catalog.get_available_formats('go')\n            &gt;&gt;&gt; isinstance(formats, list)\n            True\n        \"\"\"\n        return self.__catalog_adapter.get_available_formats(ontology_id)\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.__init__","title":"<code>__init__(cache_dir=DEFAULT_CACHE_DIR)</code>","text":"<p>Initialize the ClientCatalog.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory for caching catalog data. Defaults to DEFAULT_CACHE_DIR.</p> <code>DEFAULT_CACHE_DIR</code> Source code in <code>ontograph/client.py</code> <pre><code>def __init__(self, cache_dir: str = DEFAULT_CACHE_DIR) -&gt; None:\n    \"\"\"Initialize the ClientCatalog.\n\n    Args:\n        cache_dir (str, optional): Directory for caching catalog data. Defaults to DEFAULT_CACHE_DIR.\n    \"\"\"\n    self.__catalog_adapter = CatalogOntologies(cache_dir=Path(cache_dir))\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.catalog_as_dict","title":"<code>catalog_as_dict()</code>","text":"<p>Retrieve the ontology catalog as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The ontology catalog.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() isinstance(catalog.catalog_as_dict(), dict) True</p> Source code in <code>ontograph/client.py</code> <pre><code>def catalog_as_dict(self) -&gt; dict:\n    \"\"\"Retrieve the ontology catalog as a dictionary.\n\n    Returns:\n        dict: The ontology catalog.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; isinstance(catalog.catalog_as_dict(), dict)\n        True\n    \"\"\"\n    return self.__catalog_adapter.catalog\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.get_available_formats","title":"<code>get_available_formats(ontology_id)</code>","text":"<p>Retrieve available formats for a given ontology.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Ontology identifier.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Available formats.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() formats = catalog.get_available_formats('go') isinstance(formats, list) True</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_available_formats(self, ontology_id: str) -&gt; list[str]:\n    \"\"\"Retrieve available formats for a given ontology.\n\n    Args:\n        ontology_id (str): Ontology identifier.\n\n    Returns:\n        list[str]: Available formats.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; formats = catalog.get_available_formats('go')\n        &gt;&gt;&gt; isinstance(formats, list)\n        True\n    \"\"\"\n    return self.__catalog_adapter.get_available_formats(ontology_id)\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.get_download_url","title":"<code>get_download_url(ontology_id, format='obo')</code>","text":"<p>Retrieve the download URL for a specific ontology and format.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Ontology identifier.</p> required <code>format</code> <code>str</code> <p>Format (e.g., 'obo', 'json'). Defaults to 'obo'.</p> <code>'obo'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Download URL.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() url = catalog.get_download_url('go') isinstance(url, str) True</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_download_url(self, ontology_id: str, format: str = 'obo') -&gt; str:\n    \"\"\"Retrieve the download URL for a specific ontology and format.\n\n    Args:\n        ontology_id (str): Ontology identifier.\n        format (str, optional): Format (e.g., 'obo', 'json'). Defaults to 'obo'.\n\n    Returns:\n        str: Download URL.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; url = catalog.get_download_url('go')\n        &gt;&gt;&gt; isinstance(url, str)\n        True\n    \"\"\"\n    return self.__catalog_adapter.get_download_url(ontology_id, format)\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.get_ontology_metadata","title":"<code>get_ontology_metadata(ontology_id, show_metadata=False)</code>","text":"<p>Retrieve metadata for a specific ontology.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Ontology identifier.</p> required <code>show_metadata</code> <code>bool</code> <p>Include detailed metadata. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metadata for the specified ontology.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() meta = catalog.get_ontology_metadata('go') isinstance(meta, dict) True</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_ontology_metadata(\n    self, ontology_id: str, show_metadata: bool = False\n) -&gt; dict:\n    \"\"\"Retrieve metadata for a specific ontology.\n\n    Args:\n        ontology_id (str): Ontology identifier.\n        show_metadata (bool, optional): Include detailed metadata. Defaults to False.\n\n    Returns:\n        dict: Metadata for the specified ontology.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; meta = catalog.get_ontology_metadata('go')\n        &gt;&gt;&gt; isinstance(meta, dict)\n        True\n    \"\"\"\n    return self.__catalog_adapter.get_ontology_metadata(\n        ontology_id, show_metadata=show_metadata\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.list_available_ontologies","title":"<code>list_available_ontologies()</code>","text":"<p>List all available ontologies in the catalog.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: List of ontology metadata dictionaries.</p> Example <p>catalog = ClientCatalog() catalog.load_catalog() isinstance(catalog.list_available_ontologies(), list) True</p> Source code in <code>ontograph/client.py</code> <pre><code>def list_available_ontologies(self) -&gt; list[dict]:\n    \"\"\"List all available ontologies in the catalog.\n\n    Returns:\n        list[dict]: List of ontology metadata dictionaries.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n        &gt;&gt;&gt; isinstance(catalog.list_available_ontologies(), list)\n        True\n    \"\"\"\n    return self.__catalog_adapter.list_available_ontologies()\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.load_catalog","title":"<code>load_catalog(force_download=False)</code>","text":"<p>Load the ontology catalog.</p> <p>Parameters:</p> Name Type Description Default <code>force_download</code> <code>bool</code> <p>Force download of catalog data. Defaults to False.</p> <code>False</code> Example <p>catalog = ClientCatalog() catalog.load_catalog()</p> Source code in <code>ontograph/client.py</code> <pre><code>def load_catalog(self, force_download: bool = False) -&gt; None:\n    \"\"\"Load the ontology catalog.\n\n    Args:\n        force_download (bool, optional): Force download of catalog data. Defaults to False.\n\n    Example:\n        &gt;&gt;&gt; catalog = ClientCatalog()\n        &gt;&gt;&gt; catalog.load_catalog()\n    \"\"\"\n    return self.__catalog_adapter.load_catalog(\n        force_download=force_download\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.print_available_ontologies","title":"<code>print_available_ontologies()</code>","text":"<p>Print all available ontologies in the catalog.</p> Example <ul> <li>catalog = ClientCatalog()</li> <li>catalog.load_catalog()</li> <li>catalog.print_available_ontologies()</li> </ul> Source code in <code>ontograph/client.py</code> <pre><code>def print_available_ontologies(self) -&gt; None:\n    \"\"\"Print all available ontologies in the catalog.\n\n    Example:\n        - catalog = ClientCatalog()\n        - catalog.load_catalog()\n        - catalog.print_available_ontologies()\n    \"\"\"\n    return self.__catalog_adapter.print_available_ontologies()\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#ontograph.client.ClientCatalog.print_catalog_schema_tree","title":"<code>print_catalog_schema_tree()</code>","text":"<p>Print the schema tree of the ontology catalog.</p> Example <ul> <li>catalog = ClientCatalog()</li> <li>catalog.print_catalog_schema_tree()</li> </ul> Source code in <code>ontograph/client.py</code> <pre><code>def print_catalog_schema_tree(self) -&gt; None:\n    \"\"\"Print the schema tree of the ontology catalog.\n\n    Example:\n        - catalog = ClientCatalog()\n        - catalog.print_catalog_schema_tree()\n    \"\"\"\n    self.__catalog_adapter.print_catalog_schema_tree()\n</code></pre>"},{"location":"reference/source/ontograph/client-catalog/#see-also","title":"See Also","text":"<ul> <li>ClientOntology: For loading and querying individual ontologies.</li> </ul>"},{"location":"reference/source/ontograph/client-ontology/","title":"ClientOntology","text":"<p><code>ClientOntology</code> is the main interface for loading, navigating, and querying individual ontologies in OntoGraph. It allows you to load ontologies from local files, the OBO Foundry catalog, or remote URLs, and provides a unified API for exploring ontology terms, relationships, and structure.</p> <p>This class is ideal for users who want to work directly with a specific ontology\u2014navigating its graph, analyzing relationships, and performing introspection tasks.</p>"},{"location":"reference/source/ontograph/client-ontology/#features","title":"Features","text":"<ul> <li>Load ontologies from file, catalog, or URL</li> <li>Navigate ontology graphs: get parents, children, ancestors, descendants, siblings, and roots of terms</li> <li>Analyze relationships: check ancestor/descendant/sibling status, find common and lowest common ancestors, compute distances</li> <li>Introspect ontology structure: calculate paths, trajectories, and visualize term hierarchies</li> <li>Modular query adapters for navigation, relations, and introspection</li> </ul>"},{"location":"reference/source/ontograph/client-ontology/#api-reference","title":"API Reference","text":"<p>Client for loading and querying a single ontology.</p> <p>Supports loading from file, catalog, or URL, and provides navigation, relation, and introspection methods.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_root() [Term('Z', name='root')]</p> Source code in <code>ontograph/client.py</code> <pre><code>class ClientOntology:\n    \"\"\"Client for loading and querying a single ontology.\n\n    Supports loading from file, catalog, or URL, and provides navigation, relation, and introspection methods.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_root()\n        [Term('Z', name='root')]\n    \"\"\"\n\n    def __init__(self, cache_dir: str = DEFAULT_CACHE_DIR) -&gt; None:\n        \"\"\"Initialize the ClientOntology.\n\n        Args:\n            cache_dir (str, optional): Directory for caching ontology data. Defaults to DEFAULT_CACHE_DIR.\n        \"\"\"\n        self._cache_dir = Path(cache_dir)\n        self._ontology = None\n        self._lookup_tables = None\n        self._navigator = None\n        self._relations = None\n        self._introspection = None\n\n    def __create_graphblas_ontology(\n        self, ontology: Ontology, include_obsolete: bool = False\n    ) -&gt; tuple[LookUpTables, Graph]:\n        terms = extract_terms(\n            ontology=ontology, include_obsolete=include_obsolete\n        )\n\n        # Step 2. Extract Lookup Tables and DataFrames\n        lookup_tables = LookUpTables(terms=terms)\n\n        # Step 3. Create Nodes objects\n        # Step 3.1. Create Nodes DataFrame\n        nodes_df = NodesDataframe(\n            terms=terms, include_obsolete=include_obsolete\n        )\n        # Step 3.2. Create Nodes Indexes\n        nodes_indexes = NodeContainer(\n            nodes_indices=nodes_df.get_dataframe()['index'].to_numpy(dtype=int)\n        )\n\n        # Step 4. Create Edges objects\n        # Step 4.1. Create Edges DataFrame\n        edges_df = EdgesDataframe(\n            terms=terms, include_obsolete=include_obsolete\n        )\n        # Step 4.2. Create Edges Indexes\n        edges_indexes = EdgesContainer(terms=terms, lookup_tables=lookup_tables)\n\n        # Step 5. Create Graph object\n        graph = Graph(\n            nodes_indexes=nodes_indexes,\n            nodes_dataframe=nodes_df,\n            edges_indexes=edges_indexes,\n            edges_dataframe=edges_df,\n            lookup_tables=lookup_tables,\n        )\n\n        return lookup_tables, graph\n\n    def _detect_source_type(self, source: str) -&gt; str:\n        \"\"\"Detect the type of ontology source: file path, OBO Foundry ID, or URL.\n\n        This method checks the input string and determines its type in the following priority order:\n        1. Local file path\n        2. OBO Foundry identifier (alphanumeric, underscore, or hyphen; no slashes or dots)\n        3. HTTP/HTTPS URL\n\n        Args:\n            source (str): The ontology source string to check. Can be a file path, OBO Foundry ID, or URL.\n\n        Returns:\n            str: The detected source type. One of 'file', 'obo', or 'url'.\n\n        Raises:\n            ValueError: If the source type cannot be determined.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; client._detect_source_type(\"./ontology.obo\")\n            'file'\n            &gt;&gt;&gt; client._detect_source_type(\"go\")\n            'obo'\n            &gt;&gt;&gt; client._detect_source_type(\"https://example.com/ontology.obo\")\n            'url'\n        \"\"\"\n        path = Path(source)\n\n        # 1. File path takes highest priority\n        if path.exists() and path.is_file():\n            return 'file'\n\n        # 2. OBO Foundry ontology name (simple identifier, no slashes or dots)\n        if re.fullmatch(r'[A-Za-z0-9_-]+', source):\n            return 'obo'\n\n        # 3. URL (fallback)\n        if re.match(r'^https?://', source):\n            return 'url'\n\n        raise ValueError(f\"Cannot determine ontology source type: '{source}'\")\n\n    def load(\n        self,\n        source: str,\n        downloader: DownloaderPort = None,\n        include_obsolete: bool = False,\n        backend: str = 'pronto',\n    ) -&gt; None:\n        \"\"\"Load an ontology from a file path, URL, or OBO Foundry catalog.\n\n        This method detects the source type and loads the ontology using the appropriate strategy:\n        - Local file path\n        - URL\n        - OBO Foundry catalog identifier\n\n        It also initializes query adapters for navigation, relations, and introspection based on the selected backend.\n\n        Args:\n            source (str): Path to the ontology file, URL, or OBO Foundry identifier.\n            downloader (DownloaderPort, optional): Downloader adapter for remote files. Defaults to None.\n            include_obsolete (bool, optional): If True, include obsolete terms when building GraphBLAS structures. Defaults to False.\n            backend (str, optional): Backend for queries ('pronto' or 'graphblas'). Defaults to 'pronto'.\n\n        Raises:\n            FileNotFoundError: If the ontology source cannot be found as a file, URL, or catalog entry.\n            ValueError: If an unknown backend is specified.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; client.load(source=\"./tests/resources/dummy_ontology.obo\")\n        \"\"\"\n        logger.info(f'Loading ontology from source: {source} ...')\n        loader = ProntoLoaderAdapter(cache_dir=self._cache_dir)\n\n        path = Path(source)\n        ontology = None\n\n        # 1. Case 1: Local file exists\n        if path.exists():\n            logger.info(\n                f'Found local file at {path}, loading with ProntoLoaderAdapter...'\n            )\n            ontology = loader.load_from_file(file_path_ontology=path)\n\n        # 2. Case 2: Provided source is a URL\n        elif re.match(r'^https?://', source):\n            logger.info(\n                f'Detected URL source, downloading ontology from {source}'\n            )\n            filename = Path(source).name or 'ontology.obo'\n            ontology = loader.load_from_url(source, filename, downloader)\n\n        # 3. Case 3: Try OBO catalog (if file missing or simple ID)\n        else:\n            catalog_client = ClientCatalog(cache_dir=self._cache_dir)\n            catalog_client.load_catalog()\n            available = [\n                o['id'] for o in catalog_client.list_available_ontologies()\n            ]\n            name_id = Path(source).stem.lower()\n\n            if name_id in available:\n                logger.info(\n                    f\"Ontology '{name_id}' found in catalog, downloading...\"\n                )\n                ontology = loader.load_from_catalog(\n                    name_id=name_id, format='obo'\n                )\n            else:\n                msg = f\"Ontology '{source}' not found as file, URL, or catalog entry.\"\n                logger.error(msg)\n                raise FileNotFoundError(msg)\n\n        # 4. Graph backend construction\n        logger.info(f'Using backend: {backend}')\n        if backend == 'pronto':\n            self._ontology = ontology\n            self._lookup_tables = None\n\n        elif backend == 'graphblas':\n            self._lookup_tables, self._ontology = (\n                self.__create_graphblas_ontology(\n                    ontology=ontology.get_ontology(),\n                    include_obsolete=include_obsolete,\n                )\n            )\n        else:\n            raise ValueError(f'Unknown backend specified: {backend}')\n\n        # Initialize queries\n        logger.info('Initialize queries sequence.')\n        self._initialize_queries(backend)\n\n        logger.info('Ontology loading complete.')\n\n    def _initialize_queries(self, backend: str) -&gt; None:\n        \"\"\"Initializes query adapters for navigation, relations, and introspection based on the specified backend.\n\n        Args:\n            backend (str): The backend to use for query adapters. Supported values are 'pronto' and 'graphblas'.\n\n        Raises:\n            KeyError: If the specified backend is not supported.\n\n        \"\"\"\n\n        if backend == 'pronto':\n            self._navigator = NavigatorPronto(ontology=self._get_ontology)\n            self._relations = RelationsPronto(navigator=self._navigator)\n            self._introspection = IntrospectionPronto(\n                navigator=self._navigator,\n                relations=self._relations,\n            )\n        elif backend == 'graphblas':\n            self._navigator = NavigatorGraphblas(\n                ontology=self._get_ontology, lookup_tables=self._lookup_tables\n            )\n            self._relations = RelationsGraphblas(\n                navigator=self._navigator, lookup_tables=self._lookup_tables\n            )\n            self._introspection = IntrospectionGraphblas(\n                navigator=self._navigator,\n                relations=self._relations,\n                lookup_tables=self._lookup_tables,\n            )\n\n    @property\n    def _get_ontology(self) -&gt; Ontology:\n        \"\"\"Access the loaded ontology.\n\n        Returns:\n            Ontology: The loaded ontology.\n\n        Raises:\n            RuntimeError: If ontology not loaded.\n\n        \"\"\"\n        if self._ontology is None:\n            raise RuntimeError('Ontology not loaded. Call `load()` first.')\n        return self._ontology\n\n    # ---- Navigation Methods\n    def get_term(self, term_id: str) -&gt; object:\n        \"\"\"Retrieve a term by its ID.\n\n        Args:\n            term_id (str): Term identifier.\n\n        Returns:\n            object: Term object.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_term(\"A\")\n            Term('A', name='termA')\n        \"\"\"\n        return self._navigator.get_term(term_id=term_id)\n\n    def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Get parent terms of a given term.\n\n        Args:\n            term_id (str): Term identifier.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            list: Parent term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_parents(\"D\")\n            ['A']\n        \"\"\"\n        term_ids = self._navigator.get_parents(\n            term_id=term_id, include_self=include_self\n        )\n        return TermList(term_ids, self._lookup_tables)\n        # return self._navigator.get_parents(\n        #     term_id=term_id, include_self=include_self\n        # )\n\n    def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Get child terms of a given term.\n\n        Args:\n            term_id (str): Term identifier.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            list: Child term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_children(\"D\")\n            ['E', 'F', 'G']\n        \"\"\"\n        term_ids = self._navigator.get_children(\n            term_id=term_id, include_self=include_self\n        )\n        return TermList(term_ids, self._lookup_tables)\n\n        # return self._navigator.get_children(\n        #     term_id=term_id, include_self=include_self\n        # )\n\n    def get_ancestors(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; list[str]:\n        \"\"\"Get ancestor terms of a given term.\n\n        Args:\n            term_id (str): Term identifier.\n            distance (int, optional): Maximum distance from term. Defaults to None.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            list[str]: Ancestor term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_ancestors(\"D\")\n            ['A', 'Z']\n        \"\"\"\n        term_ids = self._navigator.get_ancestors(\n            term_id=term_id,\n            distance=distance,\n            include_self=include_self,\n        )\n        return TermList(term_ids, self._lookup_tables)\n        # return self._navigator.get_ancestors(\n        #     term_id=term_id,\n        #     distance=distance,\n        #     include_self=include_self,\n        # )\n\n    def get_ancestors_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; Iterator[tuple[object, int]]:\n        \"\"\"Get ancestor terms and their distances.\n\n        Args:\n            term_id (str): Term identifier.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            Iterator[tuple[object, int]]: Iterator of (term, distance).\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; list(client.get_ancestors_with_distance(\"D\"))\n            [(Term('A', name='termA'), -1), (Term('Z', name='root'), -2)]\n        \"\"\"\n        return self._navigator.get_ancestors_with_distance(\n            term_id=term_id,\n            include_self=include_self,\n        )\n\n    def get_descendants(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; set[str]:\n        \"\"\"Get descendant terms of a given term.\n\n        Args:\n            term_id (str): Term identifier.\n            distance (int, optional): Maximum distance from term. Defaults to None.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            set[str]: Descendant term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; sorted(client.get_descendants(\"F\"))\n            ['O', 'Y']\n        \"\"\"\n        term_ids = self._navigator.get_descendants(\n            term_id=term_id,\n            distance=distance,\n            include_self=include_self,\n        )\n        return TermList(term_ids, self._lookup_tables)\n        # return self._navigator.get_descendants(\n        #     term_id=term_id,\n        #     distance=distance,\n        #     include_self=include_self,\n        # )\n\n    def get_descendants_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; Iterator[tuple[object, int]]:\n        \"\"\"Get descendant terms and their distances.\n\n        Args:\n            term_id (str): Term identifier.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            Iterator[tuple[object, int]]: Iterator of (term, distance).\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; list(client.get_descendants_with_distance(\"F\"))\n            [(Term('O', name='termO'), 1), (Term('Y', name='termY'), 1)]\n        \"\"\"\n        return self._navigator.get_descendants_with_distance(\n            term_id=term_id,\n            include_self=include_self,\n        )\n\n    def get_siblings(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; set[str]:\n        \"\"\"Get sibling terms of a given term.\n\n        Args:\n            term_id (str): Term identifier.\n            include_self (bool, optional): Include the term itself. Defaults to False.\n\n        Returns:\n            set[str]: Sibling term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; sorted(client.get_siblings(\"F\"))\n            ['E', 'G']\n\n        \"\"\"\n        term_ids = self._navigator.get_siblings(\n            term_id=term_id, include_self=include_self\n        )\n        return TermList(term_ids, self._lookup_tables)\n        # return self._navigator.get_siblings(\n        #     term_id=term_id, include_self=include_self\n        # )\n\n    def get_root(self) -&gt; list:\n        \"\"\"Get root terms of the ontology.\n\n        Returns:\n            list: Root term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_root()\n            [Term('Z', name='root')]\n        \"\"\"\n        term_ids = self._navigator.get_root()\n        return TermList(term_ids, self._lookup_tables)\n        # return self._navigator.get_root()\n\n    # ---- Relation Methods\n\n    def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n        \"\"\"Check if one term is an ancestor of another.\n\n        Args:\n            ancestor_node (str): Ancestor term ID.\n            descendant_node (str): Descendant term ID.\n\n        Returns:\n            bool: True if ancestor_node is ancestor of descendant_node.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.is_ancestor(\"A\", \"N\")\n            True\n        \"\"\"\n        return self._relations.is_ancestor(\n            ancestor_node=ancestor_node,\n            descendant_node=descendant_node,\n        )\n\n    def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n        \"\"\"Check if one term is a descendant of another.\n\n        Args:\n            descendant_node (str): Descendant term ID.\n            ancestor_node (str): Ancestor term ID.\n\n        Returns:\n            bool: True if descendant_node is descendant of ancestor_node.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.is_descendant(\"N\", \"A\")\n            True\n        \"\"\"\n        return self._relations.is_descendant(\n            descendant_node=descendant_node,\n            ancestor_node=ancestor_node,\n        )\n\n    def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n        \"\"\"Check if two terms are siblings.\n\n        Args:\n            node_a (str): First term ID.\n            node_b (str): Second term ID.\n\n        Returns:\n            bool: True if node_a and node_b are siblings.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.is_sibling(\"E\", \"F\")\n            True\n        \"\"\"\n        return self._relations.is_sibling(node_a=node_a, node_b=node_b)\n\n    def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Get common ancestors of multiple terms.\n\n        Args:\n            node_ids (list[str]): List of term IDs.\n\n        Returns:\n            set: Common ancestor term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; sorted(client.get_common_ancestors([\"K\", \"L\"]))\n            ['B', 'Z']\n        \"\"\"\n        term_ids = self._relations.get_common_ancestors(node_ids=node_ids)\n        return TermList(term_ids, self._lookup_tables)\n        # return self._relations.get_common_ancestors(node_ids=node_ids)\n\n    def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Get lowest common ancestors of multiple terms.\n\n        Args:\n            node_ids (list[str]): List of term IDs.\n\n        Returns:\n            set: Lowest common ancestor term IDs.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_lowest_common_ancestors([\"K\", \"L\"])\n            {'B'}\n        \"\"\"\n        term_ids = self._relations.get_lowest_common_ancestors(\n            node_ids=node_ids\n        )\n        return TermList(term_ids, self._lookup_tables)\n        # return self._relations.get_lowest_common_ancestors(node_ids=node_ids)\n\n    # ---- Introspection Methods\n\n    def get_distance_from_root(self, term_id: str) -&gt; int | None:\n        \"\"\"Get the distance of a term from the root.\n\n        Args:\n            term_id (str): Term identifier.\n\n        Returns:\n            int | None: Distance from root, or None if not found.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_distance_from_root(\"U\")\n            6\n        \"\"\"\n        return self._introspection.get_distance_from_root(term_id=term_id)\n\n    def get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n        \"\"\"Get the path between two terms.\n\n        Args:\n            node_a (str): Start term ID.\n            node_b (str): End term ID.\n\n        Returns:\n            list[dict]: List of path steps.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_path_between(\"N\", \"D\")\n            [{'id': 'D', 'distance': 0}, {'id': 'E', 'distance': 1}, {'id': 'N', 'distance': 2}]\n            &gt;&gt;&gt; client.get_path_between(\"N\", \"C\")\n            []\n        \"\"\"\n        return self._introspection.get_path_between(\n            node_a=node_a, node_b=node_b\n        )\n\n    def get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n        \"\"\"Get all trajectories from the root to a term.\n\n        Args:\n            term_id (str): Term identifier.\n\n        Returns:\n            list[dict]: List of trajectories.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; client.get_trajectories_from_root(\"A\")\n            [[{'id': 'Z', 'name': 'root', 'distance': -1}, {'id': 'A', 'name': 'termA', 'distance': 0}]]\n        \"\"\"\n        return self._introspection.get_trajectories_from_root(term_id=term_id)\n\n    def print_term_trajectories_tree(self, trajectories: list[dict]) -&gt; None:\n        \"\"\"Print a tree representation of term trajectories.\n\n        Args:\n            trajectories (list[dict]): List of trajectories.\n\n        Example:\n            &gt;&gt;&gt; client = ClientOntology()\n            &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n            &gt;&gt;&gt; traj = client.get_trajectories_from_root(\"D\")\n            &gt;&gt;&gt; client.print_term_trajectories_tree(traj)\n            Z: root (distance=-2)\n            \u2514\u2500\u2500 A: termA (distance=-1)\n                \u2514\u2500\u2500 D: termD (distance=0)\n        \"\"\"\n        self._introspection.print_term_trajectories_tree(\n            trajectories=trajectories\n        )\n\n        return None\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.__init__","title":"<code>__init__(cache_dir=DEFAULT_CACHE_DIR)</code>","text":"<p>Initialize the ClientOntology.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>Directory for caching ontology data. Defaults to DEFAULT_CACHE_DIR.</p> <code>DEFAULT_CACHE_DIR</code> Source code in <code>ontograph/client.py</code> <pre><code>def __init__(self, cache_dir: str = DEFAULT_CACHE_DIR) -&gt; None:\n    \"\"\"Initialize the ClientOntology.\n\n    Args:\n        cache_dir (str, optional): Directory for caching ontology data. Defaults to DEFAULT_CACHE_DIR.\n    \"\"\"\n    self._cache_dir = Path(cache_dir)\n    self._ontology = None\n    self._lookup_tables = None\n    self._navigator = None\n    self._relations = None\n    self._introspection = None\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_ancestors","title":"<code>get_ancestors(term_id, distance=None, include_self=False)</code>","text":"<p>Get ancestor terms of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>distance</code> <code>int</code> <p>Maximum distance from term. Defaults to None.</p> <code>None</code> <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Ancestor term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_ancestors(\"D\") ['A', 'Z']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_ancestors(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; list[str]:\n    \"\"\"Get ancestor terms of a given term.\n\n    Args:\n        term_id (str): Term identifier.\n        distance (int, optional): Maximum distance from term. Defaults to None.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        list[str]: Ancestor term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_ancestors(\"D\")\n        ['A', 'Z']\n    \"\"\"\n    term_ids = self._navigator.get_ancestors(\n        term_id=term_id,\n        distance=distance,\n        include_self=include_self,\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_ancestors_with_distance","title":"<code>get_ancestors_with_distance(term_id, include_self=False)</code>","text":"<p>Get ancestor terms and their distances.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[tuple[object, int]]</code> <p>Iterator[tuple[object, int]]: Iterator of (term, distance).</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") list(client.get_ancestors_with_distance(\"D\")) [(Term('A', name='termA'), -1), (Term('Z', name='root'), -2)]</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_ancestors_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; Iterator[tuple[object, int]]:\n    \"\"\"Get ancestor terms and their distances.\n\n    Args:\n        term_id (str): Term identifier.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        Iterator[tuple[object, int]]: Iterator of (term, distance).\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; list(client.get_ancestors_with_distance(\"D\"))\n        [(Term('A', name='termA'), -1), (Term('Z', name='root'), -2)]\n    \"\"\"\n    return self._navigator.get_ancestors_with_distance(\n        term_id=term_id,\n        include_self=include_self,\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_children","title":"<code>get_children(term_id, include_self=False)</code>","text":"<p>Get child terms of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Child term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_children(\"D\") ['E', 'F', 'G']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Get child terms of a given term.\n\n    Args:\n        term_id (str): Term identifier.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        list: Child term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_children(\"D\")\n        ['E', 'F', 'G']\n    \"\"\"\n    term_ids = self._navigator.get_children(\n        term_id=term_id, include_self=include_self\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_common_ancestors","title":"<code>get_common_ancestors(node_ids)</code>","text":"<p>Get common ancestors of multiple terms.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>list[str]</code> <p>List of term IDs.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Common ancestor term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") sorted(client.get_common_ancestors([\"K\", \"L\"])) ['B', 'Z']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Get common ancestors of multiple terms.\n\n    Args:\n        node_ids (list[str]): List of term IDs.\n\n    Returns:\n        set: Common ancestor term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; sorted(client.get_common_ancestors([\"K\", \"L\"]))\n        ['B', 'Z']\n    \"\"\"\n    term_ids = self._relations.get_common_ancestors(node_ids=node_ids)\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_descendants","title":"<code>get_descendants(term_id, distance=None, include_self=False)</code>","text":"<p>Get descendant terms of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>distance</code> <code>int</code> <p>Maximum distance from term. Defaults to None.</p> <code>None</code> <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Descendant term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") sorted(client.get_descendants(\"F\")) ['O', 'Y']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_descendants(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; set[str]:\n    \"\"\"Get descendant terms of a given term.\n\n    Args:\n        term_id (str): Term identifier.\n        distance (int, optional): Maximum distance from term. Defaults to None.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        set[str]: Descendant term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; sorted(client.get_descendants(\"F\"))\n        ['O', 'Y']\n    \"\"\"\n    term_ids = self._navigator.get_descendants(\n        term_id=term_id,\n        distance=distance,\n        include_self=include_self,\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_descendants_with_distance","title":"<code>get_descendants_with_distance(term_id, include_self=False)</code>","text":"<p>Get descendant terms and their distances.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[tuple[object, int]]</code> <p>Iterator[tuple[object, int]]: Iterator of (term, distance).</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") list(client.get_descendants_with_distance(\"F\")) [(Term('O', name='termO'), 1), (Term('Y', name='termY'), 1)]</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_descendants_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; Iterator[tuple[object, int]]:\n    \"\"\"Get descendant terms and their distances.\n\n    Args:\n        term_id (str): Term identifier.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        Iterator[tuple[object, int]]: Iterator of (term, distance).\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; list(client.get_descendants_with_distance(\"F\"))\n        [(Term('O', name='termO'), 1), (Term('Y', name='termY'), 1)]\n    \"\"\"\n    return self._navigator.get_descendants_with_distance(\n        term_id=term_id,\n        include_self=include_self,\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_distance_from_root","title":"<code>get_distance_from_root(term_id)</code>","text":"<p>Get the distance of a term from the root.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Distance from root, or None if not found.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_distance_from_root(\"U\") 6</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_distance_from_root(self, term_id: str) -&gt; int | None:\n    \"\"\"Get the distance of a term from the root.\n\n    Args:\n        term_id (str): Term identifier.\n\n    Returns:\n        int | None: Distance from root, or None if not found.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_distance_from_root(\"U\")\n        6\n    \"\"\"\n    return self._introspection.get_distance_from_root(term_id=term_id)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_lowest_common_ancestors","title":"<code>get_lowest_common_ancestors(node_ids)</code>","text":"<p>Get lowest common ancestors of multiple terms.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>list[str]</code> <p>List of term IDs.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Lowest common ancestor term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_lowest_common_ancestors([\"K\", \"L\"])</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Get lowest common ancestors of multiple terms.\n\n    Args:\n        node_ids (list[str]): List of term IDs.\n\n    Returns:\n        set: Lowest common ancestor term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_lowest_common_ancestors([\"K\", \"L\"])\n        {'B'}\n    \"\"\"\n    term_ids = self._relations.get_lowest_common_ancestors(\n        node_ids=node_ids\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_parents","title":"<code>get_parents(term_id, include_self=False)</code>","text":"<p>Get parent terms of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Parent term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_parents(\"D\") ['A']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Get parent terms of a given term.\n\n    Args:\n        term_id (str): Term identifier.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        list: Parent term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_parents(\"D\")\n        ['A']\n    \"\"\"\n    term_ids = self._navigator.get_parents(\n        term_id=term_id, include_self=include_self\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_path_between","title":"<code>get_path_between(node_a, node_b)</code>","text":"<p>Get the path between two terms.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>str</code> <p>Start term ID.</p> required <code>node_b</code> <code>str</code> <p>End term ID.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: List of path steps.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_path_between(\"N\", \"D\") [{'id': 'D', 'distance': 0}, {'id': 'E', 'distance': 1}, {'id': 'N', 'distance': 2}] client.get_path_between(\"N\", \"C\") []</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n    \"\"\"Get the path between two terms.\n\n    Args:\n        node_a (str): Start term ID.\n        node_b (str): End term ID.\n\n    Returns:\n        list[dict]: List of path steps.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_path_between(\"N\", \"D\")\n        [{'id': 'D', 'distance': 0}, {'id': 'E', 'distance': 1}, {'id': 'N', 'distance': 2}]\n        &gt;&gt;&gt; client.get_path_between(\"N\", \"C\")\n        []\n    \"\"\"\n    return self._introspection.get_path_between(\n        node_a=node_a, node_b=node_b\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_root","title":"<code>get_root()</code>","text":"<p>Get root terms of the ontology.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Root term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_root() [Term('Z', name='root')]</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_root(self) -&gt; list:\n    \"\"\"Get root terms of the ontology.\n\n    Returns:\n        list: Root term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_root()\n        [Term('Z', name='root')]\n    \"\"\"\n    term_ids = self._navigator.get_root()\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_siblings","title":"<code>get_siblings(term_id, include_self=False)</code>","text":"<p>Get sibling terms of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <code>include_self</code> <code>bool</code> <p>Include the term itself. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Sibling term IDs.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") sorted(client.get_siblings(\"F\")) ['E', 'G']</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_siblings(\n    self, term_id: str, include_self: bool = False\n) -&gt; set[str]:\n    \"\"\"Get sibling terms of a given term.\n\n    Args:\n        term_id (str): Term identifier.\n        include_self (bool, optional): Include the term itself. Defaults to False.\n\n    Returns:\n        set[str]: Sibling term IDs.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; sorted(client.get_siblings(\"F\"))\n        ['E', 'G']\n\n    \"\"\"\n    term_ids = self._navigator.get_siblings(\n        term_id=term_id, include_self=include_self\n    )\n    return TermList(term_ids, self._lookup_tables)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_term","title":"<code>get_term(term_id)</code>","text":"<p>Retrieve a term by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>Term object.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_term(\"A\") Term('A', name='termA')</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_term(self, term_id: str) -&gt; object:\n    \"\"\"Retrieve a term by its ID.\n\n    Args:\n        term_id (str): Term identifier.\n\n    Returns:\n        object: Term object.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_term(\"A\")\n        Term('A', name='termA')\n    \"\"\"\n    return self._navigator.get_term(term_id=term_id)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.get_trajectories_from_root","title":"<code>get_trajectories_from_root(term_id)</code>","text":"<p>Get all trajectories from the root to a term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>Term identifier.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: List of trajectories.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.get_trajectories_from_root(\"A\") [[{'id': 'Z', 'name': 'root', 'distance': -1}, {'id': 'A', 'name': 'termA', 'distance': 0}]]</p> Source code in <code>ontograph/client.py</code> <pre><code>def get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n    \"\"\"Get all trajectories from the root to a term.\n\n    Args:\n        term_id (str): Term identifier.\n\n    Returns:\n        list[dict]: List of trajectories.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.get_trajectories_from_root(\"A\")\n        [[{'id': 'Z', 'name': 'root', 'distance': -1}, {'id': 'A', 'name': 'termA', 'distance': 0}]]\n    \"\"\"\n    return self._introspection.get_trajectories_from_root(term_id=term_id)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.is_ancestor","title":"<code>is_ancestor(ancestor_node, descendant_node)</code>","text":"<p>Check if one term is an ancestor of another.</p> <p>Parameters:</p> Name Type Description Default <code>ancestor_node</code> <code>str</code> <p>Ancestor term ID.</p> required <code>descendant_node</code> <code>str</code> <p>Descendant term ID.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ancestor_node is ancestor of descendant_node.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.is_ancestor(\"A\", \"N\") True</p> Source code in <code>ontograph/client.py</code> <pre><code>def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n    \"\"\"Check if one term is an ancestor of another.\n\n    Args:\n        ancestor_node (str): Ancestor term ID.\n        descendant_node (str): Descendant term ID.\n\n    Returns:\n        bool: True if ancestor_node is ancestor of descendant_node.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.is_ancestor(\"A\", \"N\")\n        True\n    \"\"\"\n    return self._relations.is_ancestor(\n        ancestor_node=ancestor_node,\n        descendant_node=descendant_node,\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.is_descendant","title":"<code>is_descendant(descendant_node, ancestor_node)</code>","text":"<p>Check if one term is a descendant of another.</p> <p>Parameters:</p> Name Type Description Default <code>descendant_node</code> <code>str</code> <p>Descendant term ID.</p> required <code>ancestor_node</code> <code>str</code> <p>Ancestor term ID.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if descendant_node is descendant of ancestor_node.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.is_descendant(\"N\", \"A\") True</p> Source code in <code>ontograph/client.py</code> <pre><code>def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n    \"\"\"Check if one term is a descendant of another.\n\n    Args:\n        descendant_node (str): Descendant term ID.\n        ancestor_node (str): Ancestor term ID.\n\n    Returns:\n        bool: True if descendant_node is descendant of ancestor_node.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.is_descendant(\"N\", \"A\")\n        True\n    \"\"\"\n    return self._relations.is_descendant(\n        descendant_node=descendant_node,\n        ancestor_node=ancestor_node,\n    )\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.is_sibling","title":"<code>is_sibling(node_a, node_b)</code>","text":"<p>Check if two terms are siblings.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>str</code> <p>First term ID.</p> required <code>node_b</code> <code>str</code> <p>Second term ID.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if node_a and node_b are siblings.</p> Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") client.is_sibling(\"E\", \"F\") True</p> Source code in <code>ontograph/client.py</code> <pre><code>def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n    \"\"\"Check if two terms are siblings.\n\n    Args:\n        node_a (str): First term ID.\n        node_b (str): Second term ID.\n\n    Returns:\n        bool: True if node_a and node_b are siblings.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; client.is_sibling(\"E\", \"F\")\n        True\n    \"\"\"\n    return self._relations.is_sibling(node_a=node_a, node_b=node_b)\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.load","title":"<code>load(source, downloader=None, include_obsolete=False, backend='pronto')</code>","text":"<p>Load an ontology from a file path, URL, or OBO Foundry catalog.</p> <p>This method detects the source type and loads the ontology using the appropriate strategy: - Local file path - URL - OBO Foundry catalog identifier</p> <p>It also initializes query adapters for navigation, relations, and introspection based on the selected backend.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the ontology file, URL, or OBO Foundry identifier.</p> required <code>downloader</code> <code>DownloaderPort</code> <p>Downloader adapter for remote files. Defaults to None.</p> <code>None</code> <code>include_obsolete</code> <code>bool</code> <p>If True, include obsolete terms when building GraphBLAS structures. Defaults to False.</p> <code>False</code> <code>backend</code> <code>str</code> <p>Backend for queries ('pronto' or 'graphblas'). Defaults to 'pronto'.</p> <code>'pronto'</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the ontology source cannot be found as a file, URL, or catalog entry.</p> <code>ValueError</code> <p>If an unknown backend is specified.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>client = ClientOntology() client.load(source=\"./tests/resources/dummy_ontology.obo\")</p> Source code in <code>ontograph/client.py</code> <pre><code>def load(\n    self,\n    source: str,\n    downloader: DownloaderPort = None,\n    include_obsolete: bool = False,\n    backend: str = 'pronto',\n) -&gt; None:\n    \"\"\"Load an ontology from a file path, URL, or OBO Foundry catalog.\n\n    This method detects the source type and loads the ontology using the appropriate strategy:\n    - Local file path\n    - URL\n    - OBO Foundry catalog identifier\n\n    It also initializes query adapters for navigation, relations, and introspection based on the selected backend.\n\n    Args:\n        source (str): Path to the ontology file, URL, or OBO Foundry identifier.\n        downloader (DownloaderPort, optional): Downloader adapter for remote files. Defaults to None.\n        include_obsolete (bool, optional): If True, include obsolete terms when building GraphBLAS structures. Defaults to False.\n        backend (str, optional): Backend for queries ('pronto' or 'graphblas'). Defaults to 'pronto'.\n\n    Raises:\n        FileNotFoundError: If the ontology source cannot be found as a file, URL, or catalog entry.\n        ValueError: If an unknown backend is specified.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; client.load(source=\"./tests/resources/dummy_ontology.obo\")\n    \"\"\"\n    logger.info(f'Loading ontology from source: {source} ...')\n    loader = ProntoLoaderAdapter(cache_dir=self._cache_dir)\n\n    path = Path(source)\n    ontology = None\n\n    # 1. Case 1: Local file exists\n    if path.exists():\n        logger.info(\n            f'Found local file at {path}, loading with ProntoLoaderAdapter...'\n        )\n        ontology = loader.load_from_file(file_path_ontology=path)\n\n    # 2. Case 2: Provided source is a URL\n    elif re.match(r'^https?://', source):\n        logger.info(\n            f'Detected URL source, downloading ontology from {source}'\n        )\n        filename = Path(source).name or 'ontology.obo'\n        ontology = loader.load_from_url(source, filename, downloader)\n\n    # 3. Case 3: Try OBO catalog (if file missing or simple ID)\n    else:\n        catalog_client = ClientCatalog(cache_dir=self._cache_dir)\n        catalog_client.load_catalog()\n        available = [\n            o['id'] for o in catalog_client.list_available_ontologies()\n        ]\n        name_id = Path(source).stem.lower()\n\n        if name_id in available:\n            logger.info(\n                f\"Ontology '{name_id}' found in catalog, downloading...\"\n            )\n            ontology = loader.load_from_catalog(\n                name_id=name_id, format='obo'\n            )\n        else:\n            msg = f\"Ontology '{source}' not found as file, URL, or catalog entry.\"\n            logger.error(msg)\n            raise FileNotFoundError(msg)\n\n    # 4. Graph backend construction\n    logger.info(f'Using backend: {backend}')\n    if backend == 'pronto':\n        self._ontology = ontology\n        self._lookup_tables = None\n\n    elif backend == 'graphblas':\n        self._lookup_tables, self._ontology = (\n            self.__create_graphblas_ontology(\n                ontology=ontology.get_ontology(),\n                include_obsolete=include_obsolete,\n            )\n        )\n    else:\n        raise ValueError(f'Unknown backend specified: {backend}')\n\n    # Initialize queries\n    logger.info('Initialize queries sequence.')\n    self._initialize_queries(backend)\n\n    logger.info('Ontology loading complete.')\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#ontograph.client.ClientOntology.print_term_trajectories_tree","title":"<code>print_term_trajectories_tree(trajectories)</code>","text":"<p>Print a tree representation of term trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list[dict]</code> <p>List of trajectories.</p> required Example <p>client = ClientOntology() ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\") traj = client.get_trajectories_from_root(\"D\") client.print_term_trajectories_tree(traj) Z: root (distance=-2) \u2514\u2500\u2500 A: termA (distance=-1)     \u2514\u2500\u2500 D: termD (distance=0)</p> Source code in <code>ontograph/client.py</code> <pre><code>def print_term_trajectories_tree(self, trajectories: list[dict]) -&gt; None:\n    \"\"\"Print a tree representation of term trajectories.\n\n    Args:\n        trajectories (list[dict]): List of trajectories.\n\n    Example:\n        &gt;&gt;&gt; client = ClientOntology()\n        &gt;&gt;&gt; ontology = client.load(file_path_ontology=\"./tests/resources/dummy_ontology.obo\")\n        &gt;&gt;&gt; traj = client.get_trajectories_from_root(\"D\")\n        &gt;&gt;&gt; client.print_term_trajectories_tree(traj)\n        Z: root (distance=-2)\n        \u2514\u2500\u2500 A: termA (distance=-1)\n            \u2514\u2500\u2500 D: termD (distance=0)\n    \"\"\"\n    self._introspection.print_term_trajectories_tree(\n        trajectories=trajectories\n    )\n\n    return None\n</code></pre>"},{"location":"reference/source/ontograph/client-ontology/#see-also","title":"See Also","text":"<ul> <li>ClientCatalog: For exploring and retrieving metadata from the ontology</li> </ul>"},{"location":"reference/source/ontograph/downloader/","title":"downloader","text":"<p>This module provides interfaces and adapters for downloading ontology files from URLs and catalogs.</p>"},{"location":"reference/source/ontograph/downloader/#api-reference","title":"API Reference","text":"<p>Provides functionality to download ontology files from URLs and catalogs.</p> <p>This module defines abstract interfaces and concrete implementations for downloading ontology resources from both direct URLs and ontology catalogs.</p>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.DownloadManagerAdapter","title":"<code>DownloadManagerAdapter</code>","text":"<p>               Bases: <code>DownloaderPort</code></p> <p>Alternative downloader implementation.</p> <p>Placeholder class for a implement the adapter using the <code>downloader-manager</code> by Saezlab.</p> Source code in <code>ontograph/downloader.py</code> <pre><code>class DownloadManagerAdapter(DownloaderPort):\n    \"\"\"Alternative downloader implementation.\n\n    Placeholder class for a implement the adapter using the\n    `downloader-manager` by Saezlab.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.DownloaderPort","title":"<code>DownloaderPort</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for ontology downloaders.</p> <p>Defines the contract for classes that can download ontologies from URLs or catalogs.</p> Source code in <code>ontograph/downloader.py</code> <pre><code>class DownloaderPort(ABC):\n    \"\"\"Abstract interface for ontology downloaders.\n\n    Defines the contract for classes that can download ontologies from URLs\n    or catalogs.\n    \"\"\"\n\n    @abstractmethod\n    def fetch_from_url(self, url_ontology: str, filename: str | None) -&gt; Path:\n        \"\"\"Download an ontology file from a specified URL.\n\n        Args:\n            url_ontology: URL pointing to the ontology file\n            filename: Name to save the file as\n\n        Returns:\n            Path: Path to the downloaded file\n\n        Raises:\n            ValueError: If the URL or filename is empty\n            RequestException: If the download fails\n            IOError: If saving the file fails\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def fetch_from_catalog(\n        self, resources: list[dict[str, str]], catalog: CatalogOntologies\n    ) -&gt; dict[str, Path]:\n        \"\"\"Download multiple ontology files defined in a catalog.\n\n        Args:\n            resources: list of dictionaries with resource information\n            catalog: Catalog object containing download URLs\n\n        Returns:\n            dict[str, Path]: dictionary mapping resource IDs to file paths\n\n        Raises:\n            ValueError: If the resources list is empty\n            KeyError: If a resource is missing required fields\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.DownloaderPort-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.DownloaderPort.fetch_from_catalog","title":"<code>fetch_from_catalog(resources, catalog)</code>  <code>abstractmethod</code>","text":"<p>Download multiple ontology files defined in a catalog.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[dict[str, str]]</code> <p>list of dictionaries with resource information</p> required <code>catalog</code> <code>CatalogOntologies</code> <p>Catalog object containing download URLs</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, Path]: dictionary mapping resource IDs to file paths</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resources list is empty</p> <code>KeyError</code> <p>If a resource is missing required fields</p> Source code in <code>ontograph/downloader.py</code> <pre><code>@abstractmethod\ndef fetch_from_catalog(\n    self, resources: list[dict[str, str]], catalog: CatalogOntologies\n) -&gt; dict[str, Path]:\n    \"\"\"Download multiple ontology files defined in a catalog.\n\n    Args:\n        resources: list of dictionaries with resource information\n        catalog: Catalog object containing download URLs\n\n    Returns:\n        dict[str, Path]: dictionary mapping resource IDs to file paths\n\n    Raises:\n        ValueError: If the resources list is empty\n        KeyError: If a resource is missing required fields\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.DownloaderPort.fetch_from_url","title":"<code>fetch_from_url(url_ontology, filename)</code>  <code>abstractmethod</code>","text":"<p>Download an ontology file from a specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url_ontology</code> <code>str</code> <p>URL pointing to the ontology file</p> required <code>filename</code> <code>str | None</code> <p>Name to save the file as</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the downloaded file</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL or filename is empty</p> <code>RequestException</code> <p>If the download fails</p> <code>IOError</code> <p>If saving the file fails</p> Source code in <code>ontograph/downloader.py</code> <pre><code>@abstractmethod\ndef fetch_from_url(self, url_ontology: str, filename: str | None) -&gt; Path:\n    \"\"\"Download an ontology file from a specified URL.\n\n    Args:\n        url_ontology: URL pointing to the ontology file\n        filename: Name to save the file as\n\n    Returns:\n        Path: Path to the downloaded file\n\n    Raises:\n        ValueError: If the URL or filename is empty\n        RequestException: If the download fails\n        IOError: If saving the file fails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter","title":"<code>PoochDownloaderAdapter</code>","text":"<p>               Bases: <code>DownloaderPort</code></p> <p>Downloader implementation using Pooch library.</p> <p>Downloads and caches ontology files using the Pooch library.</p> Source code in <code>ontograph/downloader.py</code> <pre><code>class PoochDownloaderAdapter(DownloaderPort):\n    \"\"\"Downloader implementation using Pooch library.\n\n    Downloads and caches ontology files using the Pooch library.\n    \"\"\"\n\n    def __init__(self, cache_dir: Path) -&gt; None:\n        \"\"\"Initialize the Pooch downloader.\n\n        Args:\n            cache_dir: Directory to store downloaded files\n        \"\"\"\n        self._cache_dir = cache_dir\n        self._resources_paths: dict[str, Path] = {}\n        self._cache_dir.mkdir(parents=True, exist_ok=True)\n\n    def get_paths(self) -&gt; dict[str, Path]:\n        \"\"\"Get paths of all downloaded resources.\n\n        Returns:\n            dict[str, Path]: dictionary mapping resource IDs to file paths\n        \"\"\"\n        return self._resources_paths\n\n    def fetch_from_url(self, url_ontology: str, filename: str | None) -&gt; Path:\n        \"\"\"Download an ontology file from a specified URL.\n\n        Args:\n            url_ontology: URL pointing to the ontology file\n            filename: Name to save the file as\n\n        Returns:\n            Path: Path to the downloaded file\n\n        Raises:\n            ValueError: If the URL or filename is empty\n            RequestException: If the download fails\n            IOError: If saving the file fails\n        \"\"\"\n        self._validate_download_parameters(url_ontology, filename)\n\n        logging.info(f'Downloading ontology from {url_ontology} as {filename}')\n        try:\n            result_path = self._perform_download(url_ontology, filename)\n            self._resources_paths[filename.split('.')[0]] = result_path\n            return result_path\n        except requests.RequestException as e:\n            logging.error(f'Failed to download ontology: {e}')\n            raise\n        except OSError as e:\n            logging.error(f'Failed to save downloaded ontology: {e}')\n            raise\n\n    def _validate_download_parameters(\n        self, url_ontology: str, filename: str | None\n    ) -&gt; None:\n        if not url_ontology or not url_ontology.strip():\n            raise ValueError('URL cannot be empty')\n\n        if not filename or not filename.strip():\n            raise ValueError('Filename cannot be empty')\n\n    def _perform_download(self, url_ontology: str, filename: str) -&gt; Path:\n        resource_path = retrieve(\n            url=url_ontology,\n            known_hash=None,  # TODO: Could later integrate SHA256 checksums\n            fname=filename,\n            path=self._cache_dir,\n            progressbar=True,\n        )\n        result_path = Path(resource_path)\n        logging.info(f'Successfully downloaded ontology to {result_path}')\n        return result_path\n\n    def fetch_from_catalog(\n        self, resources: list[dict[str, str]], catalog: CatalogOntologies\n    ) -&gt; dict[str, Path]:\n        \"\"\"Download multiple ontology files defined in a catalog.\n\n        Args:\n            resources: list of dictionaries with resource information\n            catalog: Catalog object containing download URLs\n\n        Returns:\n            dict[str, Path]: dictionary mapping resource IDs to file paths\n\n        Raises:\n            ValueError: If the resources list is empty or URL not found\n            KeyError: If a resource is missing required fields\n        \"\"\"\n        if not resources:\n            raise ValueError('Resources list for batch download is empty.')\n\n        results = {}\n        for resource in resources:\n            name_id, format_type = self._extract_resource_info(resource)\n            url = self._get_resource_url(name_id, format_type, catalog)\n\n            filename = f'{name_id}.{format_type}'\n            local_path = self.fetch_from_url(\n                url_ontology=url, filename=filename\n            )\n            results[name_id] = local_path\n\n        self._resources_paths.update(results)\n        return results\n\n    def _extract_resource_info(\n        self, resource: dict[str, str]\n    ) -&gt; tuple[str, str]:\n        name_id = resource.get('name_id')\n        if not name_id:\n            raise KeyError(\"Resource dictionary must contain 'name_id' key\")\n\n        format_type = resource.get(\n            'format', DEFAULT_FORMAT_ONTOLOGY\n        )  # Default to OBO format\n        return name_id, format_type\n\n    def _get_resource_url(\n        self, name_id: str, format_type: str, catalog: CatalogOntologies\n    ) -&gt; str:\n        url = catalog.get_download_url(name_id, format_type)\n        if not url:\n            raise ValueError(\n                f'Cannot find download URL for ontology {name_id} '\n                f'in format {format_type}'\n            )\n        return url\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter.__init__","title":"<code>__init__(cache_dir)</code>","text":"<p>Initialize the Pooch downloader.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Path</code> <p>Directory to store downloaded files</p> required Source code in <code>ontograph/downloader.py</code> <pre><code>def __init__(self, cache_dir: Path) -&gt; None:\n    \"\"\"Initialize the Pooch downloader.\n\n    Args:\n        cache_dir: Directory to store downloaded files\n    \"\"\"\n    self._cache_dir = cache_dir\n    self._resources_paths: dict[str, Path] = {}\n    self._cache_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter.fetch_from_catalog","title":"<code>fetch_from_catalog(resources, catalog)</code>","text":"<p>Download multiple ontology files defined in a catalog.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[dict[str, str]]</code> <p>list of dictionaries with resource information</p> required <code>catalog</code> <code>CatalogOntologies</code> <p>Catalog object containing download URLs</p> required <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, Path]: dictionary mapping resource IDs to file paths</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resources list is empty or URL not found</p> <code>KeyError</code> <p>If a resource is missing required fields</p> Source code in <code>ontograph/downloader.py</code> <pre><code>def fetch_from_catalog(\n    self, resources: list[dict[str, str]], catalog: CatalogOntologies\n) -&gt; dict[str, Path]:\n    \"\"\"Download multiple ontology files defined in a catalog.\n\n    Args:\n        resources: list of dictionaries with resource information\n        catalog: Catalog object containing download URLs\n\n    Returns:\n        dict[str, Path]: dictionary mapping resource IDs to file paths\n\n    Raises:\n        ValueError: If the resources list is empty or URL not found\n        KeyError: If a resource is missing required fields\n    \"\"\"\n    if not resources:\n        raise ValueError('Resources list for batch download is empty.')\n\n    results = {}\n    for resource in resources:\n        name_id, format_type = self._extract_resource_info(resource)\n        url = self._get_resource_url(name_id, format_type, catalog)\n\n        filename = f'{name_id}.{format_type}'\n        local_path = self.fetch_from_url(\n            url_ontology=url, filename=filename\n        )\n        results[name_id] = local_path\n\n    self._resources_paths.update(results)\n    return results\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter.fetch_from_url","title":"<code>fetch_from_url(url_ontology, filename)</code>","text":"<p>Download an ontology file from a specified URL.</p> <p>Parameters:</p> Name Type Description Default <code>url_ontology</code> <code>str</code> <p>URL pointing to the ontology file</p> required <code>filename</code> <code>str | None</code> <p>Name to save the file as</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the downloaded file</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL or filename is empty</p> <code>RequestException</code> <p>If the download fails</p> <code>IOError</code> <p>If saving the file fails</p> Source code in <code>ontograph/downloader.py</code> <pre><code>def fetch_from_url(self, url_ontology: str, filename: str | None) -&gt; Path:\n    \"\"\"Download an ontology file from a specified URL.\n\n    Args:\n        url_ontology: URL pointing to the ontology file\n        filename: Name to save the file as\n\n    Returns:\n        Path: Path to the downloaded file\n\n    Raises:\n        ValueError: If the URL or filename is empty\n        RequestException: If the download fails\n        IOError: If saving the file fails\n    \"\"\"\n    self._validate_download_parameters(url_ontology, filename)\n\n    logging.info(f'Downloading ontology from {url_ontology} as {filename}')\n    try:\n        result_path = self._perform_download(url_ontology, filename)\n        self._resources_paths[filename.split('.')[0]] = result_path\n        return result_path\n    except requests.RequestException as e:\n        logging.error(f'Failed to download ontology: {e}')\n        raise\n    except OSError as e:\n        logging.error(f'Failed to save downloaded ontology: {e}')\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/downloader/#ontograph.downloader.PoochDownloaderAdapter.get_paths","title":"<code>get_paths()</code>","text":"<p>Get paths of all downloaded resources.</p> <p>Returns:</p> Type Description <code>dict[str, Path]</code> <p>dict[str, Path]: dictionary mapping resource IDs to file paths</p> Source code in <code>ontograph/downloader.py</code> <pre><code>def get_paths(self) -&gt; dict[str, Path]:\n    \"\"\"Get paths of all downloaded resources.\n\n    Returns:\n        dict[str, Path]: dictionary mapping resource IDs to file paths\n    \"\"\"\n    return self._resources_paths\n</code></pre>"},{"location":"reference/source/ontograph/loader/","title":"loader","text":"<p>This module provides abstract and concrete classes for loading ontologies from files, catalogs, and URLs.</p>"},{"location":"reference/source/ontograph/loader/#api-reference","title":"API Reference","text":"<p>Ontology loader module for OntoGraph.</p> <p>This module provides abstract and concrete classes for loading ontologies from files, catalogs, and URLs. It supports adapters for different ontology formats and integrates with downloader and catalog utilities.</p>"},{"location":"reference/source/ontograph/loader/#ontograph.loader-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/loader/#ontograph.loader.FastoboAdapter","title":"<code>FastoboAdapter</code>","text":"<p>               Bases: <code>OntologyLoaderPort</code></p> <p>Concrete implementation of OntologyLoaderPort for Fastobo format.</p> <p>(Not yet implemented.)</p> Source code in <code>ontograph/loader.py</code> <pre><code>class FastoboAdapter(OntologyLoaderPort):\n    \"\"\"Concrete implementation of OntologyLoaderPort for Fastobo format.\n\n    (Not yet implemented.)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.OntologyLoaderPort","title":"<code>OntologyLoaderPort</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for ontology loader ports.</p> <p>Defines the interface for loading ontologies from files, catalogs, and URLs.</p> Source code in <code>ontograph/loader.py</code> <pre><code>class OntologyLoaderPort(ABC):\n    \"\"\"Abstract base class for ontology loader ports.\n\n    Defines the interface for loading ontologies from files, catalogs, and URLs.\n    \"\"\"\n\n    @abstractmethod\n    def load_from_file(self, file_path_ontology: str | Path) -&gt; Ontology:\n        \"\"\"Load ontology from a file.\n\n        Args:\n            file_path_ontology (str | Path): Path to the ontology file.\n\n        Returns:\n            Ontology: Loaded ontology object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_from_catalog(self, name_id: str, format: str = 'obo') -&gt; Ontology:\n        \"\"\"Load ontology from a catalog.\n\n        Args:\n            name_id (str): Ontology identifier.\n            format (str, optional): Ontology format. Defaults to 'obo'.\n\n        Returns:\n            Ontology: Loaded ontology object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_from_url(\n        self,\n        url_ontology: str,\n        filename: str,\n        downloader: DownloaderPort | None = None,\n    ) -&gt; Ontology:\n        \"\"\"Load ontology from a URL.\n\n        Args:\n            url_ontology (str): URL to download the ontology from.\n            filename (str): Name to save the downloaded file as.\n            downloader (DownloaderPort | None, optional): Downloader implementation. Defaults to None.\n\n        Returns:\n            Ontology: Loaded ontology object.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.OntologyLoaderPort-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/loader/#ontograph.loader.OntologyLoaderPort.load_from_catalog","title":"<code>load_from_catalog(name_id, format='obo')</code>  <code>abstractmethod</code>","text":"<p>Load ontology from a catalog.</p> <p>Parameters:</p> Name Type Description Default <code>name_id</code> <code>str</code> <p>Ontology identifier.</p> required <code>format</code> <code>str</code> <p>Ontology format. Defaults to 'obo'.</p> <code>'obo'</code> <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded ontology object.</p> Source code in <code>ontograph/loader.py</code> <pre><code>@abstractmethod\ndef load_from_catalog(self, name_id: str, format: str = 'obo') -&gt; Ontology:\n    \"\"\"Load ontology from a catalog.\n\n    Args:\n        name_id (str): Ontology identifier.\n        format (str, optional): Ontology format. Defaults to 'obo'.\n\n    Returns:\n        Ontology: Loaded ontology object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.OntologyLoaderPort.load_from_file","title":"<code>load_from_file(file_path_ontology)</code>  <code>abstractmethod</code>","text":"<p>Load ontology from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path_ontology</code> <code>str | Path</code> <p>Path to the ontology file.</p> required <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded ontology object.</p> Source code in <code>ontograph/loader.py</code> <pre><code>@abstractmethod\ndef load_from_file(self, file_path_ontology: str | Path) -&gt; Ontology:\n    \"\"\"Load ontology from a file.\n\n    Args:\n        file_path_ontology (str | Path): Path to the ontology file.\n\n    Returns:\n        Ontology: Loaded ontology object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.OntologyLoaderPort.load_from_url","title":"<code>load_from_url(url_ontology, filename, downloader=None)</code>  <code>abstractmethod</code>","text":"<p>Load ontology from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url_ontology</code> <code>str</code> <p>URL to download the ontology from.</p> required <code>filename</code> <code>str</code> <p>Name to save the downloaded file as.</p> required <code>downloader</code> <code>DownloaderPort | None</code> <p>Downloader implementation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded ontology object.</p> Source code in <code>ontograph/loader.py</code> <pre><code>@abstractmethod\ndef load_from_url(\n    self,\n    url_ontology: str,\n    filename: str,\n    downloader: DownloaderPort | None = None,\n) -&gt; Ontology:\n    \"\"\"Load ontology from a URL.\n\n    Args:\n        url_ontology (str): URL to download the ontology from.\n        filename (str): Name to save the downloaded file as.\n        downloader (DownloaderPort | None, optional): Downloader implementation. Defaults to None.\n\n    Returns:\n        Ontology: Loaded ontology object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter","title":"<code>ProntoLoaderAdapter</code>","text":"<p>               Bases: <code>OntologyLoaderPort</code></p> <p>Concrete implementation of OntologyLoaderPort using Pronto.</p> <p>Loads ontologies from files, catalogs, and URLs using the Pronto library.</p> Source code in <code>ontograph/loader.py</code> <pre><code>class ProntoLoaderAdapter(OntologyLoaderPort):\n    \"\"\"Concrete implementation of OntologyLoaderPort using Pronto.\n\n    Loads ontologies from files, catalogs, and URLs using the Pronto library.\n    \"\"\"\n\n    def __init__(self, cache_dir: str | Path | None = None) -&gt; None:\n        \"\"\"Initialize the ProntoLoaderAdapter.\n\n        Args:\n            cache_dir (str | Path | None, optional): Directory for cached files. Defaults to None.\n        \"\"\"\n        self._cache_dir: Path | None = (\n            Path(cache_dir) if cache_dir else DEFAULT_CACHE_DIR\n        )\n        self._ontology: Ontology | None = None\n\n    @cached_property\n    def catalog(self) -&gt; CatalogOntologies:\n        \"\"\"Return the ontology catalog.\n\n        Returns:\n            CatalogOntologies: The ontology catalog instance.\n        \"\"\"\n        logger.debug('Initializing ontology catalog')\n        return CatalogOntologies(cache_dir=self._cache_dir)\n\n    @property\n    def cache_dir(self) -&gt; Path:\n        \"\"\"Return the cache directory.\n\n        Returns:\n            Path: Path to the cache directory.\n\n        Raises:\n            ValueError: If cache_dir is not set.\n        \"\"\"\n        if self._cache_dir is None:\n            raise ValueError('Cache directory not set')\n        return self._cache_dir\n\n    def _extract_ontology_id(self, ontology: pronto.Ontology) -&gt; str | None:\n        \"\"\"Extract ontology ID from metadata.\n\n        Args:\n            ontology (pronto.Ontology): Loaded pronto ontology.\n\n        Returns:\n            Optional[str]: Extracted ID or None if not found.\n        \"\"\"\n        try:\n            ontology_id: str | None = ontology.metadata.ontology\n            logger.debug(f'Raw ontology ID from metadata: {ontology_id}')\n\n            if isinstance(ontology_id, str) and (\n                '/' in ontology_id or '.' in ontology_id\n            ):\n                original_id: str = ontology_id\n                path: str = ontology_id\n                ontology_id = path.split('/')[-1].split('.')[0]\n                logger.debug(\n                    f\"Extracted ontology ID '{ontology_id}' from '{original_id}'\"\n                )\n\n            return ontology_id\n        except (AttributeError, KeyError, TypeError) as e:\n            logger.exception(\n                f'Could not extract ontology ID from metadata: {str(e)}'\n            )\n            return None\n\n    def find_file_encoding(self, file: str | Path) -&gt; str | None:\n        \"\"\"Detect the encoding of a file.\n\n        Args:\n            file (str | Path): Path to the file whose encoding should be detected.\n\n        Returns:\n            str | None: The detected encoding, or None if it cannot be determined.\n        \"\"\"\n        result = from_path(file).best()\n        return result.encoding\n\n    def _fix_malformed_dates(self, path_file: Path) -&gt; Path:\n        \"\"\"Fix malformed date formats in OBO files.\n\n        Some OBO files (e.g., PSI-MI) have dates in non-standard format:\n        - Header: \"date: 15:04:2021 22:57\" instead of ISO format (DD:MM:YYYY)\n\n        When fastobo encounters a malformed header date, it appears to corrupt\n        the date parser, causing it to fail when parsing term creation_date fields\n        (even though those are in proper ISO format). The solution is to remove\n        both the malformed header date AND all creation_date fields.\n\n        Args:\n            path_file: Path to the original OBO file\n\n        Returns:\n            Path to the fixed OBO file (original if no fixes needed, temp file if fixed)\n        \"\"\"\n        try:\n            encoding = self.find_file_encoding(path_file)\n            with open(path_file, 'r', encoding=encoding) as f:\n                content = f.read()\n\n            # Check if the file has malformed header dates (DD:MM:YYYY format)\n            malformed_date_pattern = r'^date: \\d{2}:\\d{2}:\\d{4}.*\\n'\n            match = re.search(malformed_date_pattern, content, flags=re.MULTILINE)\n\n            if not match:\n                # No malformed dates, return original file\n                return path_file\n\n            logger.warning(\n                f\"Detected malformed date format in {path_file}, fixing...\"\n            )\n\n            # Remove the malformed header date line\n            fixed_content = re.sub(\n                malformed_date_pattern,\n                '',\n                content,\n                flags=re.MULTILINE\n            )\n\n            # Also remove all creation_date fields from terms\n            # This is necessary because the malformed header date corrupts\n            # fastobo's date parser, causing it to fail on creation_date fields\n            fixed_content = re.sub(\n                r'^creation_date:.*\\n',\n                '',\n                fixed_content,\n                flags=re.MULTILINE\n            )\n\n            # Write to temporary file\n            temp_file = tempfile.NamedTemporaryFile(\n                mode='w',\n                suffix='.obo',\n                delete=False,\n                encoding=encoding\n            )\n            temp_file.write(fixed_content)\n            temp_file.close()\n\n            logger.info(\n                f\"Fixed malformed dates in {path_file}, using temporary file: {temp_file.name}\"\n            )\n            return Path(temp_file.name)\n\n        except Exception as e:\n            logger.warning(f\"Failed to fix malformed dates: {e}, using original file\")\n            return path_file\n\n    def _load_ontology(\n        self, path_file: Path\n    ) -&gt; tuple[pronto.Ontology, str | None]:\n        \"\"\"Internal helper method to load an ontology file.\n\n        Args:\n            path_file (Path): Path to ontology file.\n\n        Returns:\n            tuple: (ontology, ontology_id).\n\n        Raises:\n            FileNotFoundError: If file doesn't exist.\n            ValueError: If parsing fails.\n        \"\"\"\n        logger.debug(f'Loading ontology from file: {path_file}')\n        if not path_file.exists():\n            error_msg = f'Ontology file not found: {path_file}'\n            logger.error(error_msg)\n            raise FileNotFoundError(error_msg)\n\n        # Fix malformed dates if needed\n        fixed_path = self._fix_malformed_dates(path_file)\n\n        logger.debug(f'Parsing ontology file with Pronto: {fixed_path}')\n        try:\n            ontology: pronto.Ontology = pronto.Ontology(\n                fixed_path, encoding=self.find_file_encoding(fixed_path)\n            )\n        except (TypeError, ValueError) as e:\n            error_msg = f'Failed to load ontology from {path_file}: {str(e)}'\n            logger.exception(error_msg)\n            # Clean up temp file if it was created\n            if fixed_path != path_file:\n                try:\n                    fixed_path.unlink()\n                except Exception:\n                    pass\n            raise ValueError(error_msg) from e\n\n        ontology_id: str | None = self._extract_ontology_id(ontology)\n        logger.debug(f'Loaded ontology with ID: {ontology_id}')\n\n        # Clean up temp file after successful loading (if different from original)\n        # Note: We keep the temp file until after ontology is fully loaded\n        if fixed_path != path_file:\n            try:\n                fixed_path.unlink()\n                logger.debug(f'Cleaned up temporary file: {fixed_path}')\n            except Exception as e:\n                logger.warning(f'Failed to clean up temporary file {fixed_path}: {e}')\n\n        return ontology, ontology_id\n\n    def _create_ontology_object(\n        self,\n        ontology_source: pronto.Ontology,\n        ontology_id: str | None,\n        metadata: dict[str, Any],\n        source_description: str,\n    ) -&gt; Ontology:\n        \"\"\"Create an Ontology object with logging.\n\n        Args:\n            ontology_source (pronto.Ontology): The source ontology object.\n            ontology_id (str | None): ID for the ontology.\n            metadata (dict[str, Any]): Metadata for the ontology.\n            source_description (str): Description of source for logging purposes.\n\n        Returns:\n            Ontology: The created ontology object.\n\n        Raises:\n            Exception: If ontology creation fails.\n        \"\"\"\n        try:\n            logger.debug(f'Creating Ontology object with ID: {ontology_id}')\n            ontology = Ontology(\n                ontology_source=ontology_source,\n                ontology_id=ontology_id,\n                metadata=metadata,\n            )\n            logger.debug(\n                f'Successfully loaded ontology from {source_description}'\n            )\n            return ontology\n        except Exception as e:\n            error_msg = (\n                f'Error creating Ontology object for {ontology_id}: {str(e)}'\n            )\n            logger.exception(error_msg)\n            raise Exception(error_msg) from e\n\n    def load_from_file(self, file_path_ontology: str | Path) -&gt; Ontology:\n        \"\"\"Load ontology from a file.\n\n        Args:\n            file_path_ontology (str | Path): Path to the ontology file.\n\n        Returns:\n            Ontology: Loaded Ontology object.\n\n        Raises:\n            FileNotFoundError: If file doesn't exist.\n            ValueError: If parsing fails.\n        \"\"\"\n        file_path = Path(file_path_ontology)\n        try:\n            ontology_object, ontology_id = self._load_ontology(file_path)\n            return self._create_ontology_object(\n                ontology_source=ontology_object,\n                ontology_id=ontology_id,\n                metadata=ontology_object.metadata.annotations,\n                source_description=f'file: {file_path}',\n            )\n        except (FileNotFoundError, ValueError) as e:\n            logger.exception(\n                f'Error loading ontology from file {file_path}: {str(e)}'\n            )\n            raise\n\n    def _download_ontology(self, name_id: str, format: str) -&gt; Path:\n        \"\"\"Download ontology from catalog.\n\n        Args:\n            name_id (str): Ontology identifier.\n            format (str): Ontology format.\n\n        Returns:\n            Path: Path to downloaded file.\n\n        Raises:\n            FileNotFoundError: If file can't be downloaded.\n            NotImplementedError: If download functionality is not implemented.\n        \"\"\"\n        downloader = PoochDownloaderAdapter(cache_dir=self.cache_dir)\n        logger.debug(f'Created default downloader: {type(downloader).__name__}')\n\n        resources = [{'name_id': name_id, 'format': format}]\n        try:\n            path_download = downloader.fetch_from_catalog(\n                resources=resources, catalog=self.catalog\n            )\n        except NotImplementedError as err:\n            logger.error(f'Download functionality not implemented: {err}')\n            raise NotImplementedError(\n                f'Download functionality not implemented: {err}'\n            ) from err\n        except Exception as err:\n            logger.exception(\n                f'Error downloading ontology {name_id} in format {format}: {err}'\n            )\n            raise RuntimeError(\n                f'Failed to download ontology {name_id} in format {format}: {err}'\n            ) from err\n\n        return path_download[name_id]\n\n    def load_from_catalog(self, name_id: str, format: str = 'obo') -&gt; Ontology:\n        \"\"\"Load ontology from the OBO Foundry catalog, downloading if needed.\n\n        Args:\n            name_id (str): Ontology identifier.\n            format (str, optional): Ontology format. Defaults to \"obo\".\n\n        Returns:\n            Ontology: Loaded Ontology object.\n\n        Raises:\n            ValueError: If format is unsupported.\n            FileNotFoundError: If file can't be found/downloaded.\n            RuntimeError: For other errors.\n        \"\"\"\n        logger.debug(f'Loading ontology from catalog: {name_id}.{format}')\n\n        if format.lower() not in SUPPORTED_FORMATS_ONTOGRAPH:\n            logger.error(f'Unsupported format requested: {format}')\n            raise ValueError(f'Unsupported format: {format}')\n\n        file_path: Path = self.cache_dir.joinpath(f'{name_id}.{format}')\n        logger.debug(f'Looking for ontology file at: {file_path}')\n\n        if not file_path.exists():\n            logger.debug(\n                f'Ontology file not found locally, downloading: {name_id}.{format}'\n            )\n            file_path = self._download_ontology(name_id, format)\n\n        logger.debug(f'Loading ontology from file: {file_path}')\n        ontology_source, _ = self._load_ontology(file_path)\n\n        logger.debug(f'Retrieving metadata for ontology: {name_id}')\n        metadata: dict[str, Any] = self.catalog.get_ontology_metadata(\n            ontology_id=name_id\n        )\n\n        return self._create_ontology_object(\n            ontology_source=ontology_source,\n            ontology_id=name_id,\n            metadata=metadata,\n            source_description=f'registry: {name_id}',\n        )\n\n    def load_from_url(\n        self,\n        url_ontology: str,\n        filename: str,\n        downloader: DownloaderPort | None = None,\n    ) -&gt; Ontology:\n        \"\"\"Load ontology from URL.\n\n        Args:\n            url_ontology (str): URL to download from.\n            filename (str): Name to save the file as.\n            downloader (DownloaderPort | None, optional): Downloader implementation. Defaults to None.\n\n        Returns:\n            Ontology: Loaded Ontology object.\n\n        Raises:\n            FileNotFoundError: If file can't be downloaded.\n            ValueError: If parsing fails.\n        \"\"\"\n        if downloader is None:\n            downloader = PoochDownloaderAdapter(cache_dir=self.cache_dir)\n            logger.debug(\n                f'Created default downloader: {type(downloader).__name__}'\n            )\n\n        file_path: Path = downloader.fetch_from_url(\n            url_ontology=url_ontology,\n            filename=filename,\n        )\n        logger.debug(f'Downloaded ontology to: {file_path}')\n\n        ontology_source, ontology_id = self._load_ontology(file_path)\n\n        return self._create_ontology_object(\n            ontology_source=ontology_source,\n            ontology_id=ontology_id,\n            metadata=ontology_source.metadata.annotations,\n            source_description=f'URL: {url_ontology}',\n        )\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter-attributes","title":"Attributes","text":""},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.cache_dir","title":"<code>cache_dir</code>  <code>property</code>","text":"<p>Return the cache directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the cache directory.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cache_dir is not set.</p>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.catalog","title":"<code>catalog</code>  <code>cached</code> <code>property</code>","text":"<p>Return the ontology catalog.</p> <p>Returns:</p> Name Type Description <code>CatalogOntologies</code> <code>CatalogOntologies</code> <p>The ontology catalog instance.</p>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.__init__","title":"<code>__init__(cache_dir=None)</code>","text":"<p>Initialize the ProntoLoaderAdapter.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str | Path | None</code> <p>Directory for cached files. Defaults to None.</p> <code>None</code> Source code in <code>ontograph/loader.py</code> <pre><code>def __init__(self, cache_dir: str | Path | None = None) -&gt; None:\n    \"\"\"Initialize the ProntoLoaderAdapter.\n\n    Args:\n        cache_dir (str | Path | None, optional): Directory for cached files. Defaults to None.\n    \"\"\"\n    self._cache_dir: Path | None = (\n        Path(cache_dir) if cache_dir else DEFAULT_CACHE_DIR\n    )\n    self._ontology: Ontology | None = None\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.find_file_encoding","title":"<code>find_file_encoding(file)</code>","text":"<p>Detect the encoding of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to the file whose encoding should be detected.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The detected encoding, or None if it cannot be determined.</p> Source code in <code>ontograph/loader.py</code> <pre><code>def find_file_encoding(self, file: str | Path) -&gt; str | None:\n    \"\"\"Detect the encoding of a file.\n\n    Args:\n        file (str | Path): Path to the file whose encoding should be detected.\n\n    Returns:\n        str | None: The detected encoding, or None if it cannot be determined.\n    \"\"\"\n    result = from_path(file).best()\n    return result.encoding\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.load_from_catalog","title":"<code>load_from_catalog(name_id, format='obo')</code>","text":"<p>Load ontology from the OBO Foundry catalog, downloading if needed.</p> <p>Parameters:</p> Name Type Description Default <code>name_id</code> <code>str</code> <p>Ontology identifier.</p> required <code>format</code> <code>str</code> <p>Ontology format. Defaults to \"obo\".</p> <code>'obo'</code> <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded Ontology object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If format is unsupported.</p> <code>FileNotFoundError</code> <p>If file can't be found/downloaded.</p> <code>RuntimeError</code> <p>For other errors.</p> Source code in <code>ontograph/loader.py</code> <pre><code>def load_from_catalog(self, name_id: str, format: str = 'obo') -&gt; Ontology:\n    \"\"\"Load ontology from the OBO Foundry catalog, downloading if needed.\n\n    Args:\n        name_id (str): Ontology identifier.\n        format (str, optional): Ontology format. Defaults to \"obo\".\n\n    Returns:\n        Ontology: Loaded Ontology object.\n\n    Raises:\n        ValueError: If format is unsupported.\n        FileNotFoundError: If file can't be found/downloaded.\n        RuntimeError: For other errors.\n    \"\"\"\n    logger.debug(f'Loading ontology from catalog: {name_id}.{format}')\n\n    if format.lower() not in SUPPORTED_FORMATS_ONTOGRAPH:\n        logger.error(f'Unsupported format requested: {format}')\n        raise ValueError(f'Unsupported format: {format}')\n\n    file_path: Path = self.cache_dir.joinpath(f'{name_id}.{format}')\n    logger.debug(f'Looking for ontology file at: {file_path}')\n\n    if not file_path.exists():\n        logger.debug(\n            f'Ontology file not found locally, downloading: {name_id}.{format}'\n        )\n        file_path = self._download_ontology(name_id, format)\n\n    logger.debug(f'Loading ontology from file: {file_path}')\n    ontology_source, _ = self._load_ontology(file_path)\n\n    logger.debug(f'Retrieving metadata for ontology: {name_id}')\n    metadata: dict[str, Any] = self.catalog.get_ontology_metadata(\n        ontology_id=name_id\n    )\n\n    return self._create_ontology_object(\n        ontology_source=ontology_source,\n        ontology_id=name_id,\n        metadata=metadata,\n        source_description=f'registry: {name_id}',\n    )\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.load_from_file","title":"<code>load_from_file(file_path_ontology)</code>","text":"<p>Load ontology from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path_ontology</code> <code>str | Path</code> <p>Path to the ontology file.</p> required <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded Ontology object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist.</p> <code>ValueError</code> <p>If parsing fails.</p> Source code in <code>ontograph/loader.py</code> <pre><code>def load_from_file(self, file_path_ontology: str | Path) -&gt; Ontology:\n    \"\"\"Load ontology from a file.\n\n    Args:\n        file_path_ontology (str | Path): Path to the ontology file.\n\n    Returns:\n        Ontology: Loaded Ontology object.\n\n    Raises:\n        FileNotFoundError: If file doesn't exist.\n        ValueError: If parsing fails.\n    \"\"\"\n    file_path = Path(file_path_ontology)\n    try:\n        ontology_object, ontology_id = self._load_ontology(file_path)\n        return self._create_ontology_object(\n            ontology_source=ontology_object,\n            ontology_id=ontology_id,\n            metadata=ontology_object.metadata.annotations,\n            source_description=f'file: {file_path}',\n        )\n    except (FileNotFoundError, ValueError) as e:\n        logger.exception(\n            f'Error loading ontology from file {file_path}: {str(e)}'\n        )\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/loader/#ontograph.loader.ProntoLoaderAdapter.load_from_url","title":"<code>load_from_url(url_ontology, filename, downloader=None)</code>","text":"<p>Load ontology from URL.</p> <p>Parameters:</p> Name Type Description Default <code>url_ontology</code> <code>str</code> <p>URL to download from.</p> required <code>filename</code> <code>str</code> <p>Name to save the file as.</p> required <code>downloader</code> <code>DownloaderPort | None</code> <p>Downloader implementation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Ontology</code> <code>Ontology</code> <p>Loaded Ontology object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file can't be downloaded.</p> <code>ValueError</code> <p>If parsing fails.</p> Source code in <code>ontograph/loader.py</code> <pre><code>def load_from_url(\n    self,\n    url_ontology: str,\n    filename: str,\n    downloader: DownloaderPort | None = None,\n) -&gt; Ontology:\n    \"\"\"Load ontology from URL.\n\n    Args:\n        url_ontology (str): URL to download from.\n        filename (str): Name to save the file as.\n        downloader (DownloaderPort | None, optional): Downloader implementation. Defaults to None.\n\n    Returns:\n        Ontology: Loaded Ontology object.\n\n    Raises:\n        FileNotFoundError: If file can't be downloaded.\n        ValueError: If parsing fails.\n    \"\"\"\n    if downloader is None:\n        downloader = PoochDownloaderAdapter(cache_dir=self.cache_dir)\n        logger.debug(\n            f'Created default downloader: {type(downloader).__name__}'\n        )\n\n    file_path: Path = downloader.fetch_from_url(\n        url_ontology=url_ontology,\n        filename=filename,\n    )\n    logger.debug(f'Downloaded ontology to: {file_path}')\n\n    ontology_source, ontology_id = self._load_ontology(file_path)\n\n    return self._create_ontology_object(\n        ontology_source=ontology_source,\n        ontology_id=ontology_id,\n        metadata=ontology_source.metadata.annotations,\n        source_description=f'URL: {url_ontology}',\n    )\n</code></pre>"},{"location":"reference/source/ontograph/models/","title":"models","text":"<p>This module defines core data structures for ontologies and catalogs used throughout OntoGraph.</p>"},{"location":"reference/source/ontograph/models/#api-reference","title":"API Reference","text":""},{"location":"reference/source/ontograph/models/#ontograph.models-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies","title":"<code>CatalogOntologies</code>","text":"<p>Manages the OBO Foundry catalog of ontologies.</p> <p>Provides methods to download, load, and query the ontology registry.</p> Source code in <code>ontograph/models.py</code> <pre><code>class CatalogOntologies:\n    \"\"\"Manages the OBO Foundry catalog of ontologies.\n\n    Provides methods to download, load, and query the ontology registry.\n    \"\"\"\n\n    def __init__(self, cache_dir: Path = DEFAULT_CACHE_DIR) -&gt; None:\n        \"\"\"Initialize the catalog manager.\n\n        Args:\n            cache_dir (Path): Directory for caching registry files.\n        \"\"\"\n        self.cache_dir = cache_dir\n        self._catalog: dict | None = None\n\n        # Create cache directory if this one doesn't exist.\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n\n    def _download_registry(self) -&gt; Path:\n        \"\"\"Download the latest catalog file.\n\n        Returns:\n            Path: Path to the downloaded catalog file.\n        \"\"\"\n        catalog_path = self.cache_dir / NAME_OBO_FOUNDRY_CATALOG\n        retrieve(\n            url=OBO_FOUNDRY_REGISTRY_URL,\n            known_hash=None,\n            fname=NAME_OBO_FOUNDRY_CATALOG,\n            path=self.cache_dir,\n        )\n        return catalog_path\n\n    def load_catalog(self, force_download: bool = False) -&gt; None:\n        \"\"\"Load the ontology catalog from disk or download if needed.\n\n        Args:\n            force_download (bool): If True, force download the catalog file.\n        \"\"\"\n        catalog_path = self.cache_dir / NAME_OBO_FOUNDRY_CATALOG\n\n        if force_download or not catalog_path.exists():\n            catalog_path = self._download_registry()\n\n        with open(catalog_path) as f:\n            self._catalog = yaml.safe_load(f)\n\n        return None\n\n    @property\n    def catalog(self) -&gt; dict:\n        \"\"\"Return the loaded catalog as a dictionary.\n\n        Returns:\n            dict: The loaded catalog.\n        \"\"\"\n        if self._catalog is None:\n            self.load_catalog()\n        return self._catalog\n\n    def list_available_ontologies(self) -&gt; list[dict]:\n        \"\"\"List available ontologies with their IDs and titles.\n\n        Returns:\n            list[dict]: List of ontologies with 'id' and 'title'.\n        \"\"\"\n        list_ontologies = [\n            {\n                'id': ont.get('id'),\n                'title': ont.get('title'),\n            }\n            for ont in self.catalog.get('ontologies', [])\n            if ont.get('id')  # Only include if it has an ID\n        ]\n\n        return list_ontologies\n\n    def print_available_ontologies(self) -&gt; None:\n        \"\"\"Print the available ontologies in a formatted table.\"\"\"\n        list_ontologies = self.list_available_ontologies()\n\n        print('{:&lt;20} {:&lt;40}'.format('name ID', 'Description'))\n        print('-' * 60)\n\n        for ontology in list_ontologies:\n            print(\n                '{:&lt;20} {:&lt;40}'.format(\n                    ontology.get('id', ''), ontology.get('title', '')\n                )\n            )\n\n    def print_catalog_schema_tree(self) -&gt; None:\n        \"\"\"Print the schema structure of the OBO Foundry registry.\"\"\"\n\n        def _print_tree(\n            data: list | dict, prefix: str = '', is_last: bool = True\n        ) -&gt; None:\n            branch = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n            child_prefix = prefix + ('    ' if is_last else '\u2502   ')\n\n            if isinstance(data, dict):\n                for key in data.keys():\n                    value = data[key]\n                    print(f'{prefix}{branch}{key}')\n                    if isinstance(value, dict):\n                        _print_tree(value, child_prefix, True)\n                    elif isinstance(value, list):\n                        print(f'{child_prefix}\u2514\u2500\u2500 [list]')\n                        if value:\n                            _print_tree(value[0], child_prefix + '    ', True)\n            elif isinstance(data, list) and data:\n                _print_tree(data[0], prefix, True)\n\n        print('\\nOBO Foundry Registry Schema Structure:\\n')\n        _print_tree(self.catalog)\n\n        return None\n\n    def get_ontology_metadata(\n        self,\n        ontology_id: str,\n        show_metadata: bool = False,\n    ) -&gt; dict:\n        \"\"\"Retrieve metadata for a specific ontology.\n\n        Args:\n            ontology_id (str): Ontology identifier.\n            show_metadata (bool): If True, pretty-print the metadata.\n\n        Returns:\n            dict: Metadata dictionary for the ontology.\n\n        Raises:\n            Exception: If metadata is not found.\n        \"\"\"\n        try:\n            for ontology in self.catalog.get('ontologies', []):\n                if ontology.get('id') == ontology_id:\n                    if show_metadata:\n                        pprint.pprint(ontology)\n                    return ontology\n        except Exception as e:\n            logger.exception(f'Metadata not found!: {e}')\n            raise\n\n    def get_download_url(\n        self,\n        ontology_id: str,\n        format: str = 'obo',\n    ) -&gt; str:\n        \"\"\"Retrieve the download URL for a specific ontology and format.\n\n        Args:\n            ontology_id (str): Identifier of the ontology.\n            format (str): Desired ontology file format (default: 'obo').\n\n        Returns:\n            str: The download URL (ontology_purl).\n\n        Raises:\n            ValueError: If the ontology or the specified format is not found in the catalog.\n        \"\"\"\n        metadata = self.get_ontology_metadata(ontology_id, show_metadata=False)\n        if metadata is None:\n            raise ValueError(\n                f\"No metadata found for ontology ID '{ontology_id}'.\"\n            )\n\n        expected_id = f'{ontology_id.lower()}.{format.lower()}'\n        products = metadata.get('products', [])\n\n        for product in products:\n            if product.get('id', '').lower() == expected_id:\n                purl = product.get('ontology_purl')\n                if purl:\n                    return purl\n                break  # Matching ID found but no URL\n\n        raise ValueError(\n            f\"Download URL not found for ontology '{ontology_id}' with format '.{format}'.\"\n        )\n\n    def get_available_formats(self, ontology_id: str) -&gt; list[str]:\n        \"\"\"Get available formats for a given ontology.\n\n        Args:\n            ontology_id (str): Ontology identifier.\n\n        Returns:\n            list[str]: List of available formats.\n        \"\"\"\n        metadata = self.get_ontology_metadata(ontology_id)\n        if not metadata:\n            print(f'The metadata associated to {ontology_id} does not exist!')\n            return []\n\n        formats = set()\n\n        for product in metadata.get('products', []):\n            if product.get('id'):\n                formats.add(product['id'].lower())\n\n        return list(formats)\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies-attributes","title":"Attributes","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.catalog","title":"<code>catalog</code>  <code>property</code>","text":"<p>Return the loaded catalog as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loaded catalog.</p>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.__init__","title":"<code>__init__(cache_dir=DEFAULT_CACHE_DIR)</code>","text":"<p>Initialize the catalog manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Path</code> <p>Directory for caching registry files.</p> <code>DEFAULT_CACHE_DIR</code> Source code in <code>ontograph/models.py</code> <pre><code>def __init__(self, cache_dir: Path = DEFAULT_CACHE_DIR) -&gt; None:\n    \"\"\"Initialize the catalog manager.\n\n    Args:\n        cache_dir (Path): Directory for caching registry files.\n    \"\"\"\n    self.cache_dir = cache_dir\n    self._catalog: dict | None = None\n\n    # Create cache directory if this one doesn't exist.\n    self.cache_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.get_available_formats","title":"<code>get_available_formats(ontology_id)</code>","text":"<p>Get available formats for a given ontology.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Ontology identifier.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of available formats.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_available_formats(self, ontology_id: str) -&gt; list[str]:\n    \"\"\"Get available formats for a given ontology.\n\n    Args:\n        ontology_id (str): Ontology identifier.\n\n    Returns:\n        list[str]: List of available formats.\n    \"\"\"\n    metadata = self.get_ontology_metadata(ontology_id)\n    if not metadata:\n        print(f'The metadata associated to {ontology_id} does not exist!')\n        return []\n\n    formats = set()\n\n    for product in metadata.get('products', []):\n        if product.get('id'):\n            formats.add(product['id'].lower())\n\n    return list(formats)\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.get_download_url","title":"<code>get_download_url(ontology_id, format='obo')</code>","text":"<p>Retrieve the download URL for a specific ontology and format.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Identifier of the ontology.</p> required <code>format</code> <code>str</code> <p>Desired ontology file format (default: 'obo').</p> <code>'obo'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The download URL (ontology_purl).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ontology or the specified format is not found in the catalog.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_download_url(\n    self,\n    ontology_id: str,\n    format: str = 'obo',\n) -&gt; str:\n    \"\"\"Retrieve the download URL for a specific ontology and format.\n\n    Args:\n        ontology_id (str): Identifier of the ontology.\n        format (str): Desired ontology file format (default: 'obo').\n\n    Returns:\n        str: The download URL (ontology_purl).\n\n    Raises:\n        ValueError: If the ontology or the specified format is not found in the catalog.\n    \"\"\"\n    metadata = self.get_ontology_metadata(ontology_id, show_metadata=False)\n    if metadata is None:\n        raise ValueError(\n            f\"No metadata found for ontology ID '{ontology_id}'.\"\n        )\n\n    expected_id = f'{ontology_id.lower()}.{format.lower()}'\n    products = metadata.get('products', [])\n\n    for product in products:\n        if product.get('id', '').lower() == expected_id:\n            purl = product.get('ontology_purl')\n            if purl:\n                return purl\n            break  # Matching ID found but no URL\n\n    raise ValueError(\n        f\"Download URL not found for ontology '{ontology_id}' with format '.{format}'.\"\n    )\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.get_ontology_metadata","title":"<code>get_ontology_metadata(ontology_id, show_metadata=False)</code>","text":"<p>Retrieve metadata for a specific ontology.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_id</code> <code>str</code> <p>Ontology identifier.</p> required <code>show_metadata</code> <code>bool</code> <p>If True, pretty-print the metadata.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Metadata dictionary for the ontology.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If metadata is not found.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_ontology_metadata(\n    self,\n    ontology_id: str,\n    show_metadata: bool = False,\n) -&gt; dict:\n    \"\"\"Retrieve metadata for a specific ontology.\n\n    Args:\n        ontology_id (str): Ontology identifier.\n        show_metadata (bool): If True, pretty-print the metadata.\n\n    Returns:\n        dict: Metadata dictionary for the ontology.\n\n    Raises:\n        Exception: If metadata is not found.\n    \"\"\"\n    try:\n        for ontology in self.catalog.get('ontologies', []):\n            if ontology.get('id') == ontology_id:\n                if show_metadata:\n                    pprint.pprint(ontology)\n                return ontology\n    except Exception as e:\n        logger.exception(f'Metadata not found!: {e}')\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.list_available_ontologies","title":"<code>list_available_ontologies()</code>","text":"<p>List available ontologies with their IDs and titles.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: List of ontologies with 'id' and 'title'.</p> Source code in <code>ontograph/models.py</code> <pre><code>def list_available_ontologies(self) -&gt; list[dict]:\n    \"\"\"List available ontologies with their IDs and titles.\n\n    Returns:\n        list[dict]: List of ontologies with 'id' and 'title'.\n    \"\"\"\n    list_ontologies = [\n        {\n            'id': ont.get('id'),\n            'title': ont.get('title'),\n        }\n        for ont in self.catalog.get('ontologies', [])\n        if ont.get('id')  # Only include if it has an ID\n    ]\n\n    return list_ontologies\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.load_catalog","title":"<code>load_catalog(force_download=False)</code>","text":"<p>Load the ontology catalog from disk or download if needed.</p> <p>Parameters:</p> Name Type Description Default <code>force_download</code> <code>bool</code> <p>If True, force download the catalog file.</p> <code>False</code> Source code in <code>ontograph/models.py</code> <pre><code>def load_catalog(self, force_download: bool = False) -&gt; None:\n    \"\"\"Load the ontology catalog from disk or download if needed.\n\n    Args:\n        force_download (bool): If True, force download the catalog file.\n    \"\"\"\n    catalog_path = self.cache_dir / NAME_OBO_FOUNDRY_CATALOG\n\n    if force_download or not catalog_path.exists():\n        catalog_path = self._download_registry()\n\n    with open(catalog_path) as f:\n        self._catalog = yaml.safe_load(f)\n\n    return None\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.print_available_ontologies","title":"<code>print_available_ontologies()</code>","text":"<p>Print the available ontologies in a formatted table.</p> Source code in <code>ontograph/models.py</code> <pre><code>def print_available_ontologies(self) -&gt; None:\n    \"\"\"Print the available ontologies in a formatted table.\"\"\"\n    list_ontologies = self.list_available_ontologies()\n\n    print('{:&lt;20} {:&lt;40}'.format('name ID', 'Description'))\n    print('-' * 60)\n\n    for ontology in list_ontologies:\n        print(\n            '{:&lt;20} {:&lt;40}'.format(\n                ontology.get('id', ''), ontology.get('title', '')\n            )\n        )\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.CatalogOntologies.print_catalog_schema_tree","title":"<code>print_catalog_schema_tree()</code>","text":"<p>Print the schema structure of the OBO Foundry registry.</p> Source code in <code>ontograph/models.py</code> <pre><code>def print_catalog_schema_tree(self) -&gt; None:\n    \"\"\"Print the schema structure of the OBO Foundry registry.\"\"\"\n\n    def _print_tree(\n        data: list | dict, prefix: str = '', is_last: bool = True\n    ) -&gt; None:\n        branch = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n        child_prefix = prefix + ('    ' if is_last else '\u2502   ')\n\n        if isinstance(data, dict):\n            for key in data.keys():\n                value = data[key]\n                print(f'{prefix}{branch}{key}')\n                if isinstance(value, dict):\n                    _print_tree(value, child_prefix, True)\n                elif isinstance(value, list):\n                    print(f'{child_prefix}\u2514\u2500\u2500 [list]')\n                    if value:\n                        _print_tree(value[0], child_prefix + '    ', True)\n        elif isinstance(data, list) and data:\n            _print_tree(data[0], prefix, True)\n\n    print('\\nOBO Foundry Registry Schema Structure:\\n')\n    _print_tree(self.catalog)\n\n    return None\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.EdgesDataframe","title":"<code>EdgesDataframe</code>","text":"Source code in <code>ontograph/models.py</code> <pre><code>class EdgesDataframe:\n    def __init__(\n        self, terms: pronto.Term, include_obsolete: bool = False\n    ) -&gt; None:\n        self.dataframe = self.create_edges_dataframe(\n            terms, include_obsolete=include_obsolete\n        )\n\n    def __get_last_part_string(\n        self, input_string: str, separators: tuple = ('/', ':', '.', '#')\n    ) -&gt; str:\n        pattern = '|'.join(map(re.escape, separators))\n        parts = re.split(pattern, input_string)\n        return parts[-1] if parts else input_string\n\n    def create_edges_dataframe(\n        self, terms: list, include_obsolete: bool = False\n    ) -&gt; 'pd.DataFrame':\n        \"\"\"Create a DataFrame with fields: source_id, source_name, relation, target_id, target_name, is_obsolete.\"\"\"\n        rows = []\n        for term in tqdm(terms, desc='Building edge dataframe', unit='term'):\n            if not include_obsolete and term.obsolete:\n                continue\n            source_id = term.id\n            source_name = term.name\n            for rel, targets in term.relationships.items():\n                rel_name = rel.name\n                for target in targets:\n                    rows.append(\n                        {\n                            'source_id': source_id,\n                            'source_name': source_name,\n                            'relation': rel_name,\n                            'target_id': target.id,\n                            'target_name': target.name,\n                            'is_obsolete': target.obsolete,\n                        }\n                    )\n            # Add is_a relationships (subclasses)\n            for subclass in term.subclasses(with_self=False, distance=1):\n                if not include_obsolete and subclass.obsolete:\n                    continue\n                rows.append(\n                    {\n                        'source_id': subclass.id,\n                        'source_name': subclass.name,\n                        'relation': 'is_a',\n                        'target_id': term.id,\n                        'target_name': term.name,\n                        'is_obsolete': subclass.obsolete,\n                    }\n                )\n\n        df = pd.DataFrame(rows)\n        df.sort_values(['source_id', 'relation', 'target_id'], inplace=True)\n        df.reset_index(drop=True, inplace=True)\n        df.insert(0, 'index', range(len(df)))\n        return df\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.EdgesDataframe-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.EdgesDataframe.create_edges_dataframe","title":"<code>create_edges_dataframe(terms, include_obsolete=False)</code>","text":"<p>Create a DataFrame with fields: source_id, source_name, relation, target_id, target_name, is_obsolete.</p> Source code in <code>ontograph/models.py</code> <pre><code>def create_edges_dataframe(\n    self, terms: list, include_obsolete: bool = False\n) -&gt; 'pd.DataFrame':\n    \"\"\"Create a DataFrame with fields: source_id, source_name, relation, target_id, target_name, is_obsolete.\"\"\"\n    rows = []\n    for term in tqdm(terms, desc='Building edge dataframe', unit='term'):\n        if not include_obsolete and term.obsolete:\n            continue\n        source_id = term.id\n        source_name = term.name\n        for rel, targets in term.relationships.items():\n            rel_name = rel.name\n            for target in targets:\n                rows.append(\n                    {\n                        'source_id': source_id,\n                        'source_name': source_name,\n                        'relation': rel_name,\n                        'target_id': target.id,\n                        'target_name': target.name,\n                        'is_obsolete': target.obsolete,\n                    }\n                )\n        # Add is_a relationships (subclasses)\n        for subclass in term.subclasses(with_self=False, distance=1):\n            if not include_obsolete and subclass.obsolete:\n                continue\n            rows.append(\n                {\n                    'source_id': subclass.id,\n                    'source_name': subclass.name,\n                    'relation': 'is_a',\n                    'target_id': term.id,\n                    'target_name': term.name,\n                    'is_obsolete': subclass.obsolete,\n                }\n            )\n\n    df = pd.DataFrame(rows)\n    df.sort_values(['source_id', 'relation', 'target_id'], inplace=True)\n    df.reset_index(drop=True, inplace=True)\n    df.insert(0, 'index', range(len(df)))\n    return df\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.NodesDataframe","title":"<code>NodesDataframe</code>","text":"Source code in <code>ontograph/models.py</code> <pre><code>class NodesDataframe:\n    def __init__(self, terms: list, include_obsolete: bool = False) -&gt; None:\n        self.dataframe = self.create_nodes_dataframe(\n            terms, include_obsolete=include_obsolete\n        )\n\n    def get_dataframe(self) -&gt; pd.DataFrame:\n        return self.dataframe\n\n    # Function to split a string by multiple separators and get the last part\n    def __get_last_part_string(\n        self, s: str, separators: tuple = ('/', ':', '.', '#')\n    ) -&gt; str:\n        # Create a regex pattern to split by any of the separators\n        pattern = '|'.join(map(re.escape, separators))\n        parts = re.split(pattern, s)\n\n        return parts[-1] if parts else s\n\n    def __get_dictitionary_annotations(self, annotations: object) -&gt; dict:\n        ann_dict = {}\n        for annotation in annotations:\n            # Get \"annotation.property\"\n            key = self.__get_last_part_string(annotation.property)\n\n            # Get elements from ResourcePropertyValue annotations\n            if isinstance(annotation, pronto.ResourcePropertyValue):\n                ann_dict[key] = {'resource': annotation.resource}\n                continue\n\n            # Get elements from LiteralPropertyValue annotations\n            elif isinstance(annotation, pronto.LiteralPropertyValue):\n                ann_dict[key] = {\n                    'literal': annotation.literal,\n                    'datatype': self.__get_last_part_string(\n                        annotation.datatype\n                    ),\n                }\n        return ann_dict\n\n    def __get_string_relationships(self, relations: pronto.Relationship) -&gt; str:\n        rel_list = [relation.name for relation in relations.keys()]\n        return ('|').join(rel_list)\n\n    def __get_dictionary_synonyms(self, synonyms: pronto.synonym) -&gt; dict:\n        syn_dict = {}\n        for synonym in synonyms:\n            entry = {\n                k: v\n                for k, v in [\n                    (\n                        'type',\n                        getattr(synonym.type, 'id', None)\n                        if synonym.type\n                        else None,\n                    ),\n                    (\n                        'source',\n                        '|'.join(str(source.id) for source in synonym.xrefs)\n                        if synonym.xrefs\n                        else None,\n                    ),\n                    (\n                        'scope',\n                        synonym.scope if synonym.scope is not None else None,\n                    ),\n                ]\n                if v is not None and v != ''\n            }\n            syn_dict[synonym.description] = entry\n        return syn_dict\n\n    def __get_dictionary_xrefs(self, xrefs: pronto.Xref) -&gt; dict:\n        xref_dict = {}\n        for xref in xrefs:\n            entry = {\n                k: v\n                for k, v in [\n                    (\n                        'description',\n                        xref.description if xref.description else None,\n                    )\n                ]\n                if v is not None and v != ''\n            }\n            xref_dict[f'{xref.id}'] = entry\n        return xref_dict\n\n    def create_nodes_dataframe(\n        self, terms: list, include_obsolete: bool = False\n    ) -&gt; pd.DataFrame:\n        \"\"\"Create a DataFrame with fields: ID, Name, Definition, Namespace, Subsets, Synonyms, Xrefs.\"\"\"\n        # Pre-bind functions for efficiency\n        join = '|'.join\n        str_ = str\n        get_ann = self.__get_dictitionary_annotations\n        get_syn = self.__get_dictionary_synonyms\n        get_xref = self.__get_dictionary_xrefs\n        get_rel = self.__get_string_relationships\n\n        # Collect data for each term\n        rows = []\n        for term in tqdm(terms, desc='Building node dataframe', unit='term'):\n            if not include_obsolete and term.obsolete:\n                continue\n\n            rows.append(\n                {\n                    'term_id': term.id,\n                    'name': term.name,\n                    'alternate_ids': join(term.alternate_ids)\n                    if term.alternate_ids\n                    else None,\n                    'namespace': term.namespace,\n                    'obsolete': term.obsolete,\n                    'anonymous': term.anonymous,\n                    'builtin': term.builtin,\n                    'created_by': term.created_by,\n                    'creation_date': term.creation_date,\n                    'replaced_by': join([r.id for r in term.replaced_by])\n                    if term.replaced_by\n                    else None,\n                    'consider': join(term.consider) if term.consider else None,\n                    'definition': str_(term.definition)\n                    if term.definition\n                    else None,\n                    'comment': term.comment,\n                    'annotations': str(get_ann(term.annotations))\n                    if term.annotations\n                    else None,\n                    'subsets': join(term.subsets) if term.subsets else None,\n                    'synonyms': str(get_syn(term.synonyms))\n                    if term.synonyms\n                    else None,\n                    'xrefs': str(get_xref(term.xrefs)) if term.xrefs else None,\n                    'relationships': get_rel(term.relationships)\n                    if term.relationships\n                    else None,\n                    'disjoint_from': term.disjoint_from\n                    if term.disjoint_from\n                    else None,\n                    'equivalent_to': term.equivalent_to\n                    if term.equivalent_to\n                    else None,\n                    'intersection_of': term.intersection_of\n                    if term.intersection_of\n                    else None,\n                }\n            )\n\n        # Create DataFrame\n        df = pd.DataFrame(rows)\n\n        # Sort by term_id and reset index\n        df.sort_values('term_id', inplace=True)\n        df.reset_index(drop=True, inplace=True)\n\n        # Add index column\n        df.insert(0, 'index', range(len(df)))\n\n        return df\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.NodesDataframe-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.NodesDataframe.create_nodes_dataframe","title":"<code>create_nodes_dataframe(terms, include_obsolete=False)</code>","text":"<p>Create a DataFrame with fields: ID, Name, Definition, Namespace, Subsets, Synonyms, Xrefs.</p> Source code in <code>ontograph/models.py</code> <pre><code>def create_nodes_dataframe(\n    self, terms: list, include_obsolete: bool = False\n) -&gt; pd.DataFrame:\n    \"\"\"Create a DataFrame with fields: ID, Name, Definition, Namespace, Subsets, Synonyms, Xrefs.\"\"\"\n    # Pre-bind functions for efficiency\n    join = '|'.join\n    str_ = str\n    get_ann = self.__get_dictitionary_annotations\n    get_syn = self.__get_dictionary_synonyms\n    get_xref = self.__get_dictionary_xrefs\n    get_rel = self.__get_string_relationships\n\n    # Collect data for each term\n    rows = []\n    for term in tqdm(terms, desc='Building node dataframe', unit='term'):\n        if not include_obsolete and term.obsolete:\n            continue\n\n        rows.append(\n            {\n                'term_id': term.id,\n                'name': term.name,\n                'alternate_ids': join(term.alternate_ids)\n                if term.alternate_ids\n                else None,\n                'namespace': term.namespace,\n                'obsolete': term.obsolete,\n                'anonymous': term.anonymous,\n                'builtin': term.builtin,\n                'created_by': term.created_by,\n                'creation_date': term.creation_date,\n                'replaced_by': join([r.id for r in term.replaced_by])\n                if term.replaced_by\n                else None,\n                'consider': join(term.consider) if term.consider else None,\n                'definition': str_(term.definition)\n                if term.definition\n                else None,\n                'comment': term.comment,\n                'annotations': str(get_ann(term.annotations))\n                if term.annotations\n                else None,\n                'subsets': join(term.subsets) if term.subsets else None,\n                'synonyms': str(get_syn(term.synonyms))\n                if term.synonyms\n                else None,\n                'xrefs': str(get_xref(term.xrefs)) if term.xrefs else None,\n                'relationships': get_rel(term.relationships)\n                if term.relationships\n                else None,\n                'disjoint_from': term.disjoint_from\n                if term.disjoint_from\n                else None,\n                'equivalent_to': term.equivalent_to\n                if term.equivalent_to\n                else None,\n                'intersection_of': term.intersection_of\n                if term.intersection_of\n                else None,\n            }\n        )\n\n    # Create DataFrame\n    df = pd.DataFrame(rows)\n\n    # Sort by term_id and reset index\n    df.sort_values('term_id', inplace=True)\n    df.reset_index(drop=True, inplace=True)\n\n    # Add index column\n    df.insert(0, 'index', range(len(df)))\n\n    return df\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology","title":"<code>Ontology</code>","text":"<p>Represents an ontology loaded from a source.</p> Source code in <code>ontograph/models.py</code> <pre><code>class Ontology:\n    \"\"\"Represents an ontology loaded from a source.\"\"\"\n\n    def __init__(\n        self,\n        ontology_source: object,\n        *,\n        ontology_id: str | None = None,\n        metadata: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the Ontology object.\n\n        Args:\n            ontology_source (Any): The loaded ontology object.\n            ontology_id (str | None, optional): Ontology identifier.\n            metadata (dict | None, optional): Metadata dictionary.\n        \"\"\"\n        self._ontology = ontology_source\n        self._ontology_id = ontology_id\n        self._metadata = metadata\n\n    def get_ontology(self) -&gt; object:\n        \"\"\"Return the underlying ontology object.\n\n        Returns:\n            Any: The loaded ontology object.\n        \"\"\"\n        return self._ontology\n\n    def get_ontology_id(self) -&gt; str | None:\n        \"\"\"Return the ontology identifier.\n\n        Returns:\n            str | None: The ontology ID.\n        \"\"\"\n        return self._ontology_id\n\n    def get_metadata(self) -&gt; dict | None:\n        \"\"\"Return the ontology metadata.\n\n        Returns:\n            dict | None: The metadata dictionary.\n        \"\"\"\n        return self._metadata\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology.__init__","title":"<code>__init__(ontology_source, *, ontology_id=None, metadata=None)</code>","text":"<p>Initialize the Ontology object.</p> <p>Parameters:</p> Name Type Description Default <code>ontology_source</code> <code>Any</code> <p>The loaded ontology object.</p> required <code>ontology_id</code> <code>str | None</code> <p>Ontology identifier.</p> <code>None</code> <code>metadata</code> <code>dict | None</code> <p>Metadata dictionary.</p> <code>None</code> Source code in <code>ontograph/models.py</code> <pre><code>def __init__(\n    self,\n    ontology_source: object,\n    *,\n    ontology_id: str | None = None,\n    metadata: dict | None = None,\n) -&gt; None:\n    \"\"\"Initialize the Ontology object.\n\n    Args:\n        ontology_source (Any): The loaded ontology object.\n        ontology_id (str | None, optional): Ontology identifier.\n        metadata (dict | None, optional): Metadata dictionary.\n    \"\"\"\n    self._ontology = ontology_source\n    self._ontology_id = ontology_id\n    self._metadata = metadata\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Return the ontology metadata.</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict | None: The metadata dictionary.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_metadata(self) -&gt; dict | None:\n    \"\"\"Return the ontology metadata.\n\n    Returns:\n        dict | None: The metadata dictionary.\n    \"\"\"\n    return self._metadata\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology.get_ontology","title":"<code>get_ontology()</code>","text":"<p>Return the underlying ontology object.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>object</code> <p>The loaded ontology object.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_ontology(self) -&gt; object:\n    \"\"\"Return the underlying ontology object.\n\n    Returns:\n        Any: The loaded ontology object.\n    \"\"\"\n    return self._ontology\n</code></pre>"},{"location":"reference/source/ontograph/models/#ontograph.models.Ontology.get_ontology_id","title":"<code>get_ontology_id()</code>","text":"<p>Return the ontology identifier.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The ontology ID.</p> Source code in <code>ontograph/models.py</code> <pre><code>def get_ontology_id(self) -&gt; str | None:\n    \"\"\"Return the ontology identifier.\n\n    Returns:\n        str | None: The ontology ID.\n    \"\"\"\n    return self._ontology_id\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/","title":"queries.introspection","text":"<p>This module provides the <code>OntologyIntrospection</code> class for introspection utilities on ontology graphs.</p>"},{"location":"reference/source/ontograph/queries/introspection/#api-reference","title":"API Reference","text":""},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas","title":"<code>IntrospectionGraphblas</code>","text":"<p>               Bases: <code>IntrospectionOntology</code></p> <p>Provides introspection utilities for ontology graphs using GraphBLAS.</p> <p>Includes methods for calculating distances, paths, and ancestor trajectories.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>class IntrospectionGraphblas(IntrospectionOntology):\n    \"\"\"Provides introspection utilities for ontology graphs using GraphBLAS.\n\n    Includes methods for calculating distances, paths, and ancestor trajectories.\n    \"\"\"\n\n    def __init__(\n        self,\n        navigator: NavigatorOntology,\n        relations: RelationsOntology,\n        lookup_tables: LookUpTables,\n    ) -&gt; None:\n        \"\"\"Initialize the introspection utility.\n\n        Args:\n            navigator (NavigatorPronto): The ontology navigator.\n            relations (RelationsPronto): The ontology relations.\n            lookup_tables (LookUpTables): Lookup tables for term/index/description mapping.\n        \"\"\"\n        self.__navigator = navigator\n        self.__relations = relations\n        self.lookup_tables = lookup_tables\n        self.matrices_container = navigator.matrices_container\n\n    def get_distance_from_root(self, term_id: str) -&gt; int:\n        \"\"\"Calculate the distance from the given term to the root node(s) of the ontology.\n\n        Parameters\n        ----------\n        term_id : str\n            The term ID for which to compute the distance from root.\n\n        Returns:\n        -------\n        int\n            Distance from the term to the root (number of edges).\n            Returns 0 if the term is a root itself.\n        \"\"\"\n        # Validate term\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        # Get all ancestors with distance\n        ancestors_with_distance = self.__navigator.get_ancestors_with_distance(\n            term_id, include_self=True\n        )\n\n        if not ancestors_with_distance:\n            # No ancestors, this term is a root\n            return 0\n\n        # Distance from root = maximum distance in the ancestors path\n        max_distance = max(distance for _, distance in ancestors_with_distance)\n\n        return max_distance\n\n    def get_path_between(self, node_a: str, node_b: str) -&gt; list:\n        \"\"\"Find the shortest path between two nodes in the ontology.\n\n        Parameters\n        ----------\n        node_a : str\n            Starting term ID.\n        node_b : str\n            Ending term ID.\n\n        Returns:\n        -------\n        List[str]\n            List of term IDs representing the path from node_a to node_b (inclusive).\n            Returns empty list if no path exists.\n        \"\"\"\n        if node_a not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {node_a}')\n        if node_b not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {node_b}')\n\n        # Check if a path exists\n        if not (\n            self.__relations.is_ancestor(node_a, node_b)\n            or self.__relations.is_descendant(node_a, node_b)\n        ):\n            return []\n\n        # Determine direction\n        if self.__relations.is_ancestor(node_a, node_b):\n            start, end = node_a, node_b\n            adjacency_matrix = self.matrices_container['is_a']\n        else:\n            start, end = node_b, node_a\n            adjacency_matrix = self.matrices_container['is_a']\n\n        start_idx = self.lookup_tables.term_to_index(start)\n        end_idx = self.lookup_tables.term_to_index(end)\n\n        # BFS to find shortest path\n\n        queue = deque([[start_idx]])\n        visited = {start_idx}\n\n        while queue:\n            path = queue.popleft()\n            current = path[-1]\n\n            if current == end_idx:\n                return self.lookup_tables.index_to_term(path)\n\n            # Get children (or parents depending on direction)\n            neighbors_vec = adjacency_matrix @ self.__navigator.one_hot_vector(\n                current\n            )\n            neighbors = neighbors_vec.to_coo()[0]\n\n            for n in neighbors:\n                if n not in visited:\n                    visited.add(n)\n                    queue.append(path + [n])\n\n        return []\n\n    def get_trajectories_from_root(self, term_id: str) -&gt; list[list[dict]]:\n        \"\"\"Get all ancestor trajectories from the root(s) to the given term using GraphBLAS operations.\n\n        Args:\n            term_id (str): The identifier of the term.\n\n        Returns:\n            list[list[dict]]: List of trajectories; each trajectory is a list of dictionaries\n                            with keys: 'id', 'name', and 'distance' (from the queried term).\n        \"\"\"\n        # Validate input\n        lut_term_to_index = self.lookup_tables.get_lut_term_to_index()\n        if term_id not in lut_term_to_index:\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        A_T = self.matrices_container['is_a'].T\n        term_idx = int(self.lookup_tables.term_to_index(term_id))\n\n        # Root detection\n        roots = set(self.__navigator.get_root())\n        root_indices = {int(self.lookup_tables.term_to_index(r)) for r in roots}\n\n        from collections import deque\n\n        queue = deque([[term_idx]])\n        trajectories = []\n\n        while queue:\n            path = queue.popleft()\n            current_idx = int(path[0])\n\n            # Parent discovery using GraphBLAS multiplication\n            parent_vec = (\n                A_T @ self.__navigator.one_hot_vector(current_idx)\n            ).new()\n            parent_indices = [int(i) for i in parent_vec.to_coo()[0]]\n\n            # Termination condition: reached a root or no parents\n            if not parent_indices or current_idx in root_indices:\n                # Reverse path \u2192 root \u2192 term order\n                reversed_path = list(reversed(path))\n                traj = []\n                for dist, idx in enumerate(\n                    reversed_path[::-1]\n                ):  # distance from term\n                    idx = int(idx)\n                    traj.append(\n                        {\n                            'id': self.lookup_tables.index_to_term(idx),\n                            'name': self.lookup_tables.term_to_description(\n                                self.lookup_tables.index_to_term(idx)\n                            ),\n                            'distance': dist,\n                        }\n                    )\n                trajectories.append(\n                    list(reversed(traj))\n                )  # ensure root\u2192term order\n            else:\n                for p in parent_indices:\n                    if p not in path:\n                        queue.append([p] + path)\n\n        for traj in trajectories:\n            traj.reverse()  # optional: reverse to have root-first order\n\n        return trajectories  # optional: reverse to have root-first order\n\n    @staticmethod\n    def print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n        \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\n\n        Combining shared nodes.\n\n        Args:\n            trajectories: List of lists, each inner list is a trajectory (branch) as returned by ancestor_trajectories.\n        \"\"\"\n        if not trajectories:\n            print('No trajectories to display.')\n            return\n        root = IntrospectionGraphblas._build_tree_from_trajectories(\n            trajectories\n        )\n        IntrospectionGraphblas._print_ascii_tree(root)\n\n    @staticmethod\n    def _build_tree_from_trajectories(trajectories: list[dict]) -&gt; object:\n        \"\"\"Build a tree structure from the list of branches (trajectories).\n\n        Returns the root node.\n\n        Args:\n            trajectories (list[dict]): List of trajectory branches.\n\n        Returns:\n            object: The root node of the tree.\n        \"\"\"\n\n        class Node:\n            def __init__(self, node_id: str, name: str, distance: int) -&gt; None:\n                self.id = node_id\n                self.name = name\n                self.distance = distance\n                self.children = {}\n\n        def insert_branch(root: Node, branch: list) -&gt; None:\n            node = root\n            for item in branch:\n                key = (item['id'], item['name'], item['distance'])\n                if key not in node.children:\n                    node.children[key] = Node(*key)\n                node = node.children[key]\n\n        # All branches are sorted from term to root, so reverse to root-to-term\n        branch_lists = [list(branch) for branch in trajectories]\n        root_info = branch_lists[0][0]\n        root = Node(root_info['id'], root_info['name'], root_info['distance'])\n        for branch in branch_lists:\n            insert_branch(root, branch[1:])  # skip root itself, already created\n        return root\n\n    @staticmethod\n    def _print_ascii_tree(root: object) -&gt; None:\n        \"\"\"Print the tree structure in ASCII format starting from the root node.\"\"\"\n\n        def print_ascii_tree(\n            node: object, prefix: str = '', is_last: bool = True\n        ) -&gt; None:\n            connector = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n            print(\n                f'{prefix}{connector}{node.id}: {node.name} (distance={node.distance})'\n            )\n            child_items = list(node.children.values())\n            for idx, child in enumerate(child_items):\n                is_last_child = idx == len(child_items) - 1\n                next_prefix = prefix + ('    ' if is_last else '\u2502   ')\n                print_ascii_tree(child, next_prefix, is_last_child)\n\n        # Print root without prefix\n        print(f'{root.id}: {root.name} (distance={root.distance})')\n        child_items = list(root.children.values())\n        for idx, child in enumerate(child_items):\n            is_last_child = idx == len(child_items) - 1\n            print_ascii_tree(child, '', is_last_child)\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.__init__","title":"<code>__init__(navigator, relations, lookup_tables)</code>","text":"<p>Initialize the introspection utility.</p> <p>Parameters:</p> Name Type Description Default <code>navigator</code> <code>NavigatorPronto</code> <p>The ontology navigator.</p> required <code>relations</code> <code>RelationsPronto</code> <p>The ontology relations.</p> required <code>lookup_tables</code> <code>LookUpTables</code> <p>Lookup tables for term/index/description mapping.</p> required Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def __init__(\n    self,\n    navigator: NavigatorOntology,\n    relations: RelationsOntology,\n    lookup_tables: LookUpTables,\n) -&gt; None:\n    \"\"\"Initialize the introspection utility.\n\n    Args:\n        navigator (NavigatorPronto): The ontology navigator.\n        relations (RelationsPronto): The ontology relations.\n        lookup_tables (LookUpTables): Lookup tables for term/index/description mapping.\n    \"\"\"\n    self.__navigator = navigator\n    self.__relations = relations\n    self.lookup_tables = lookup_tables\n    self.matrices_container = navigator.matrices_container\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_distance_from_root","title":"<code>get_distance_from_root(term_id)</code>","text":"<p>Calculate the distance from the given term to the root node(s) of the ontology.</p>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_distance_from_root--parameters","title":"Parameters","text":"<p>term_id : str     The term ID for which to compute the distance from root.</p>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_distance_from_root--returns","title":"Returns:","text":"<p>int     Distance from the term to the root (number of edges).     Returns 0 if the term is a root itself.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_distance_from_root(self, term_id: str) -&gt; int:\n    \"\"\"Calculate the distance from the given term to the root node(s) of the ontology.\n\n    Parameters\n    ----------\n    term_id : str\n        The term ID for which to compute the distance from root.\n\n    Returns:\n    -------\n    int\n        Distance from the term to the root (number of edges).\n        Returns 0 if the term is a root itself.\n    \"\"\"\n    # Validate term\n    if term_id not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {term_id}')\n\n    # Get all ancestors with distance\n    ancestors_with_distance = self.__navigator.get_ancestors_with_distance(\n        term_id, include_self=True\n    )\n\n    if not ancestors_with_distance:\n        # No ancestors, this term is a root\n        return 0\n\n    # Distance from root = maximum distance in the ancestors path\n    max_distance = max(distance for _, distance in ancestors_with_distance)\n\n    return max_distance\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_path_between","title":"<code>get_path_between(node_a, node_b)</code>","text":"<p>Find the shortest path between two nodes in the ontology.</p>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_path_between--parameters","title":"Parameters","text":"<p>node_a : str     Starting term ID. node_b : str     Ending term ID.</p>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_path_between--returns","title":"Returns:","text":"<p>List[str]     List of term IDs representing the path from node_a to node_b (inclusive).     Returns empty list if no path exists.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_path_between(self, node_a: str, node_b: str) -&gt; list:\n    \"\"\"Find the shortest path between two nodes in the ontology.\n\n    Parameters\n    ----------\n    node_a : str\n        Starting term ID.\n    node_b : str\n        Ending term ID.\n\n    Returns:\n    -------\n    List[str]\n        List of term IDs representing the path from node_a to node_b (inclusive).\n        Returns empty list if no path exists.\n    \"\"\"\n    if node_a not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {node_a}')\n    if node_b not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {node_b}')\n\n    # Check if a path exists\n    if not (\n        self.__relations.is_ancestor(node_a, node_b)\n        or self.__relations.is_descendant(node_a, node_b)\n    ):\n        return []\n\n    # Determine direction\n    if self.__relations.is_ancestor(node_a, node_b):\n        start, end = node_a, node_b\n        adjacency_matrix = self.matrices_container['is_a']\n    else:\n        start, end = node_b, node_a\n        adjacency_matrix = self.matrices_container['is_a']\n\n    start_idx = self.lookup_tables.term_to_index(start)\n    end_idx = self.lookup_tables.term_to_index(end)\n\n    # BFS to find shortest path\n\n    queue = deque([[start_idx]])\n    visited = {start_idx}\n\n    while queue:\n        path = queue.popleft()\n        current = path[-1]\n\n        if current == end_idx:\n            return self.lookup_tables.index_to_term(path)\n\n        # Get children (or parents depending on direction)\n        neighbors_vec = adjacency_matrix @ self.__navigator.one_hot_vector(\n            current\n        )\n        neighbors = neighbors_vec.to_coo()[0]\n\n        for n in neighbors:\n            if n not in visited:\n                visited.add(n)\n                queue.append(path + [n])\n\n    return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.get_trajectories_from_root","title":"<code>get_trajectories_from_root(term_id)</code>","text":"<p>Get all ancestor trajectories from the root(s) to the given term using GraphBLAS operations.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term.</p> required <p>Returns:</p> Type Description <code>list[list[dict]]</code> <p>list[list[dict]]: List of trajectories; each trajectory is a list of dictionaries             with keys: 'id', 'name', and 'distance' (from the queried term).</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_trajectories_from_root(self, term_id: str) -&gt; list[list[dict]]:\n    \"\"\"Get all ancestor trajectories from the root(s) to the given term using GraphBLAS operations.\n\n    Args:\n        term_id (str): The identifier of the term.\n\n    Returns:\n        list[list[dict]]: List of trajectories; each trajectory is a list of dictionaries\n                        with keys: 'id', 'name', and 'distance' (from the queried term).\n    \"\"\"\n    # Validate input\n    lut_term_to_index = self.lookup_tables.get_lut_term_to_index()\n    if term_id not in lut_term_to_index:\n        raise KeyError(f'Unknown term ID: {term_id}')\n\n    A_T = self.matrices_container['is_a'].T\n    term_idx = int(self.lookup_tables.term_to_index(term_id))\n\n    # Root detection\n    roots = set(self.__navigator.get_root())\n    root_indices = {int(self.lookup_tables.term_to_index(r)) for r in roots}\n\n    from collections import deque\n\n    queue = deque([[term_idx]])\n    trajectories = []\n\n    while queue:\n        path = queue.popleft()\n        current_idx = int(path[0])\n\n        # Parent discovery using GraphBLAS multiplication\n        parent_vec = (\n            A_T @ self.__navigator.one_hot_vector(current_idx)\n        ).new()\n        parent_indices = [int(i) for i in parent_vec.to_coo()[0]]\n\n        # Termination condition: reached a root or no parents\n        if not parent_indices or current_idx in root_indices:\n            # Reverse path \u2192 root \u2192 term order\n            reversed_path = list(reversed(path))\n            traj = []\n            for dist, idx in enumerate(\n                reversed_path[::-1]\n            ):  # distance from term\n                idx = int(idx)\n                traj.append(\n                    {\n                        'id': self.lookup_tables.index_to_term(idx),\n                        'name': self.lookup_tables.term_to_description(\n                            self.lookup_tables.index_to_term(idx)\n                        ),\n                        'distance': dist,\n                    }\n                )\n            trajectories.append(\n                list(reversed(traj))\n            )  # ensure root\u2192term order\n        else:\n            for p in parent_indices:\n                if p not in path:\n                    queue.append([p] + path)\n\n    for traj in trajectories:\n        traj.reverse()  # optional: reverse to have root-first order\n\n    return trajectories  # optional: reverse to have root-first order\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionGraphblas.print_term_trajectories_tree","title":"<code>print_term_trajectories_tree(trajectories)</code>  <code>staticmethod</code>","text":"<p>Print all ancestor trajectories as a single ASCII tree from root to the original term.</p> <p>Combining shared nodes.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list[dict]</code> <p>List of lists, each inner list is a trajectory (branch) as returned by ancestor_trajectories.</p> required Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@staticmethod\ndef print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n    \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\n\n    Combining shared nodes.\n\n    Args:\n        trajectories: List of lists, each inner list is a trajectory (branch) as returned by ancestor_trajectories.\n    \"\"\"\n    if not trajectories:\n        print('No trajectories to display.')\n        return\n    root = IntrospectionGraphblas._build_tree_from_trajectories(\n        trajectories\n    )\n    IntrospectionGraphblas._print_ascii_tree(root)\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology","title":"<code>IntrospectionOntology</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for ontology introspection utilities.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>class IntrospectionOntology(ABC):\n    \"\"\"Abstract class for ontology introspection utilities.\"\"\"\n\n    def __init__(\n        self, navigator: NavigatorOntology, relations: RelationsOntology\n    ) -&gt; None:\n        self._navigator = navigator\n        self._relations = relations\n\n    @abstractmethod\n    def get_distance_from_root(self, term_id: str) -&gt; int | None:\n        \"\"\"Calculate the distance from a term to the ontology root.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n        \"\"\"Find the trajectory (path) between two ontology terms.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n        \"\"\"Get all ancestor trajectories from the root to the given term.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n        \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology.get_distance_from_root","title":"<code>get_distance_from_root(term_id)</code>  <code>abstractmethod</code>","text":"<p>Calculate the distance from a term to the ontology root.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@abstractmethod\ndef get_distance_from_root(self, term_id: str) -&gt; int | None:\n    \"\"\"Calculate the distance from a term to the ontology root.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology.get_path_between","title":"<code>get_path_between(node_a, node_b)</code>  <code>abstractmethod</code>","text":"<p>Find the trajectory (path) between two ontology terms.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@abstractmethod\ndef get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n    \"\"\"Find the trajectory (path) between two ontology terms.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology.get_trajectories_from_root","title":"<code>get_trajectories_from_root(term_id)</code>  <code>abstractmethod</code>","text":"<p>Get all ancestor trajectories from the root to the given term.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@abstractmethod\ndef get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n    \"\"\"Get all ancestor trajectories from the root to the given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionOntology.print_term_trajectories_tree","title":"<code>print_term_trajectories_tree(trajectories)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Print all ancestor trajectories as a single ASCII tree from root to the original term.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n    \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto","title":"<code>IntrospectionPronto</code>","text":"<p>               Bases: <code>IntrospectionOntology</code></p> <p>Provides introspection utilities for ontology graphs.</p> <p>Includes methods for calculating distances, paths, and ancestor trajectories.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>class IntrospectionPronto(IntrospectionOntology):\n    \"\"\"Provides introspection utilities for ontology graphs.\n\n    Includes methods for calculating distances, paths, and ancestor trajectories.\n    \"\"\"\n\n    def __init__(\n        self, navigator: NavigatorOntology, relations: RelationsPronto\n    ) -&gt; None:\n        \"\"\"Initialize the introspection utility.\n\n        Args:\n            navigator (OntologyNavigator): The ontology navigator.\n            relations (OntologyRelations): The ontology relations.\n        \"\"\"\n        self.__navigator = navigator\n        self.__relations = relations\n\n    def get_distance_from_root(self, term_id: str) -&gt; int | None:\n        \"\"\"Calculate the distance from a term to the ontology root.\n\n        Args:\n            term_id (str): The identifier of the term.\n\n        Returns:\n            int | None: The distance from the term to the root, or None if not found or an error occurs.\n\n        Raises:\n            Exception: If an unexpected error occurs during distance calculation.\n        \"\"\"\n        try:\n            self.__navigator.get_term(term_id)\n        except (TypeError, AttributeError, ValueError) as e:\n            logger.error(f\"Error retrieving term for node '{term_id}': {e}\")\n            raise\n\n        try:\n            root = self.__navigator.get_root()[0].id\n            logger.debug(f'Root: {root}')\n        except (IndexError, AttributeError) as e:\n            logger.error(f'Failed to get root: {e}')\n            return None\n\n        try:\n            distance = self.__relations._get_distance_to_ancestor(term_id, root)\n        except (TypeError, AttributeError, ValueError) as e:\n            logger.error(\n                f\"Error calculating distance from '{term_id}' to root '{root}': {e}\"\n            )\n            return None\n\n        return distance\n\n    def get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n        \"\"\"Finds the trajectory (path) between two ontology terms if there is an ancestor-descendant relationship.\n\n        Args:\n            node_a (str): The ID of the first term.\n            node_b (str): The ID of the second term.\n\n        Returns:\n            list[dict]: The path as a list of dictionaries with 'id' and 'distance' keys, or an empty list if no path exists.\n\n        Raises:\n            Exception: If an unexpected error occurs during path calculation.\n        \"\"\"\n        if self.__relations.is_ancestor(\n            ancestor_node=node_a, descendant_node=node_b\n        ):\n            start, end, step = node_a, node_b, 1\n        elif self.__relations.is_ancestor(\n            ancestor_node=node_b, descendant_node=node_a\n        ):\n            start, end, step = node_b, node_a, 1\n        elif node_a == node_b:\n            return [{'id': node_a, 'distance': 0}]\n        else:\n            return []\n\n        try:\n            term = self.__navigator.get_term(start)\n        except (TypeError, AttributeError, ValueError) as e:\n            logger.error(f\"Error retrieving term for node '{start}': {e}\")\n            return []\n\n        visited = set()\n        queue = deque([(term, 0, [])])\n\n        while queue:\n            current_term, dist, current_path = queue.popleft()\n            if current_term.id in visited:\n                continue\n            visited.add(current_term.id)\n            new_path = current_path + [\n                {'id': current_term.id, 'distance': dist}\n            ]\n            if current_term.id == end:\n                return new_path\n\n            try:\n                for child in current_term.subclasses(distance=1):\n                    if child.id not in visited:\n                        queue.append((child, dist + step, new_path))\n            except (TypeError, AttributeError, ValueError) as e:\n                logger.error(\n                    f\"Error retrieving subclasses for term '{current_term.id}': {e}\"\n                )\n                continue\n\n        return []\n\n    def get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n        \"\"\"Get all ancestor trajectories from the root to the given term.\n\n        Args:\n            term_id (str): The identifier of the term.\n\n        Returns:\n            list[dict]: List of trajectories, each trajectory is a list of dicts.\n        \"\"\"\n        term = self.__navigator.get_term(term_id)\n        trajectories = []\n\n        def dfs(\n            current_term: object,\n            current_distance: int,\n            path: list,\n            visited: set,\n        ) -&gt; None:\n            # Prevent cycles\n            if current_term.id in visited:\n                return\n            # Add current term to path\n            path = path + [\n                {\n                    'id': current_term.id,\n                    'name': current_term.name,\n                    'distance': current_distance,\n                }\n            ]\n            try:\n                parents = [\n                    p\n                    for p in current_term.superclasses(distance=1)\n                    if p.id != current_term.id\n                ]\n            except (AttributeError, TypeError) as e:\n                logger.error(\n                    f\"Error retrieving superclasses for term '{current_term.id}': {e}\"\n                )\n                return\n            if not parents:\n                # Reached root, save this path\n                trajectories.append(path[::-1])\n                return\n            for parent in parents:\n                dfs(\n                    parent,\n                    current_distance - 1,\n                    path,\n                    visited | {current_term.id},\n                )\n\n        dfs(term, 0, [], set())\n        return trajectories\n\n    @staticmethod\n    def print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n        \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\n\n        For a single trajectory, print each node as '{id}: {name}'.\n        For multiple, print as ASCII tree.\n        \"\"\"\n        if not trajectories:\n            print('No trajectories to display.')\n            return\n        # If only one trajectory, print each node simply\n        if len(trajectories) == 1:\n            for node in trajectories[0]:\n                print(f'{node[\"id\"]}: {node[\"name\"]}')\n            return\n        # Otherwise, use tree printing\n        root = IntrospectionOntology._build_tree_from_trajectories(trajectories)\n        IntrospectionOntology._print_ascii_tree(root)\n\n    @staticmethod\n    def _build_tree_from_trajectories(trajectories: list[dict]) -&gt; object:\n        \"\"\"Build a tree structure from the list of branches (trajectories).\n\n        Returns the root node.\n\n        Args:\n            trajectories (list[dict]): List of trajectory branches.\n\n        Returns:\n            object: The root node of the tree.\n        \"\"\"\n\n        class Node:\n            def __init__(self, node_id: str, name: str, distance: int) -&gt; None:\n                self.id = node_id\n                self.name = name\n                self.distance = distance\n                self.children = {}\n\n        def insert_branch(root: Node, branch: list) -&gt; None:\n            node = root\n            for item in branch:\n                key = (item['id'], item['name'], item['distance'])\n                if key not in node.children:\n                    node.children[key] = Node(*key)\n                node = node.children[key]\n\n        # All branches are sorted from term to root, so reverse to root-to-term\n        branch_lists = [list(branch) for branch in trajectories]\n        root_info = branch_lists[0][0]\n        root = Node(root_info['id'], root_info['name'], root_info['distance'])\n        for branch in branch_lists:\n            insert_branch(root, branch[1:])  # skip root itself, already created\n        return root\n\n    @staticmethod\n    def _print_ascii_tree(root: object) -&gt; None:\n        \"\"\"Print the tree structure in ASCII format starting from the root node.\"\"\"\n\n        def print_ascii_tree(\n            node: object, prefix: str = '', is_last: bool = True\n        ) -&gt; None:\n            connector = '\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '\n            print(\n                f'{prefix}{connector}{node.id}: {node.name} (distance={node.distance})'\n            )\n            child_items = list(node.children.values())\n            for idx, child in enumerate(child_items):\n                is_last_child = idx == len(child_items) - 1\n                next_prefix = prefix + ('    ' if is_last else '\u2502   ')\n                print_ascii_tree(child, next_prefix, is_last_child)\n\n        # Print root without prefix\n        print(f'{root.id}: {root.name} (distance={root.distance})')\n        child_items = list(root.children.values())\n        for idx, child in enumerate(child_items):\n            is_last_child = idx == len(child_items) - 1\n            print_ascii_tree(child, '', is_last_child)\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto.__init__","title":"<code>__init__(navigator, relations)</code>","text":"<p>Initialize the introspection utility.</p> <p>Parameters:</p> Name Type Description Default <code>navigator</code> <code>OntologyNavigator</code> <p>The ontology navigator.</p> required <code>relations</code> <code>OntologyRelations</code> <p>The ontology relations.</p> required Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def __init__(\n    self, navigator: NavigatorOntology, relations: RelationsPronto\n) -&gt; None:\n    \"\"\"Initialize the introspection utility.\n\n    Args:\n        navigator (OntologyNavigator): The ontology navigator.\n        relations (OntologyRelations): The ontology relations.\n    \"\"\"\n    self.__navigator = navigator\n    self.__relations = relations\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto.get_distance_from_root","title":"<code>get_distance_from_root(term_id)</code>","text":"<p>Calculate the distance from a term to the ontology root.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The distance from the term to the root, or None if not found or an error occurs.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an unexpected error occurs during distance calculation.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_distance_from_root(self, term_id: str) -&gt; int | None:\n    \"\"\"Calculate the distance from a term to the ontology root.\n\n    Args:\n        term_id (str): The identifier of the term.\n\n    Returns:\n        int | None: The distance from the term to the root, or None if not found or an error occurs.\n\n    Raises:\n        Exception: If an unexpected error occurs during distance calculation.\n    \"\"\"\n    try:\n        self.__navigator.get_term(term_id)\n    except (TypeError, AttributeError, ValueError) as e:\n        logger.error(f\"Error retrieving term for node '{term_id}': {e}\")\n        raise\n\n    try:\n        root = self.__navigator.get_root()[0].id\n        logger.debug(f'Root: {root}')\n    except (IndexError, AttributeError) as e:\n        logger.error(f'Failed to get root: {e}')\n        return None\n\n    try:\n        distance = self.__relations._get_distance_to_ancestor(term_id, root)\n    except (TypeError, AttributeError, ValueError) as e:\n        logger.error(\n            f\"Error calculating distance from '{term_id}' to root '{root}': {e}\"\n        )\n        return None\n\n    return distance\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto.get_path_between","title":"<code>get_path_between(node_a, node_b)</code>","text":"<p>Finds the trajectory (path) between two ontology terms if there is an ancestor-descendant relationship.</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>str</code> <p>The ID of the first term.</p> required <code>node_b</code> <code>str</code> <p>The ID of the second term.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: The path as a list of dictionaries with 'id' and 'distance' keys, or an empty list if no path exists.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an unexpected error occurs during path calculation.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_path_between(self, node_a: str, node_b: str) -&gt; list[dict]:\n    \"\"\"Finds the trajectory (path) between two ontology terms if there is an ancestor-descendant relationship.\n\n    Args:\n        node_a (str): The ID of the first term.\n        node_b (str): The ID of the second term.\n\n    Returns:\n        list[dict]: The path as a list of dictionaries with 'id' and 'distance' keys, or an empty list if no path exists.\n\n    Raises:\n        Exception: If an unexpected error occurs during path calculation.\n    \"\"\"\n    if self.__relations.is_ancestor(\n        ancestor_node=node_a, descendant_node=node_b\n    ):\n        start, end, step = node_a, node_b, 1\n    elif self.__relations.is_ancestor(\n        ancestor_node=node_b, descendant_node=node_a\n    ):\n        start, end, step = node_b, node_a, 1\n    elif node_a == node_b:\n        return [{'id': node_a, 'distance': 0}]\n    else:\n        return []\n\n    try:\n        term = self.__navigator.get_term(start)\n    except (TypeError, AttributeError, ValueError) as e:\n        logger.error(f\"Error retrieving term for node '{start}': {e}\")\n        return []\n\n    visited = set()\n    queue = deque([(term, 0, [])])\n\n    while queue:\n        current_term, dist, current_path = queue.popleft()\n        if current_term.id in visited:\n            continue\n        visited.add(current_term.id)\n        new_path = current_path + [\n            {'id': current_term.id, 'distance': dist}\n        ]\n        if current_term.id == end:\n            return new_path\n\n        try:\n            for child in current_term.subclasses(distance=1):\n                if child.id not in visited:\n                    queue.append((child, dist + step, new_path))\n        except (TypeError, AttributeError, ValueError) as e:\n            logger.error(\n                f\"Error retrieving subclasses for term '{current_term.id}': {e}\"\n            )\n            continue\n\n    return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto.get_trajectories_from_root","title":"<code>get_trajectories_from_root(term_id)</code>","text":"<p>Get all ancestor trajectories from the root to the given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: List of trajectories, each trajectory is a list of dicts.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>def get_trajectories_from_root(self, term_id: str) -&gt; list[dict]:\n    \"\"\"Get all ancestor trajectories from the root to the given term.\n\n    Args:\n        term_id (str): The identifier of the term.\n\n    Returns:\n        list[dict]: List of trajectories, each trajectory is a list of dicts.\n    \"\"\"\n    term = self.__navigator.get_term(term_id)\n    trajectories = []\n\n    def dfs(\n        current_term: object,\n        current_distance: int,\n        path: list,\n        visited: set,\n    ) -&gt; None:\n        # Prevent cycles\n        if current_term.id in visited:\n            return\n        # Add current term to path\n        path = path + [\n            {\n                'id': current_term.id,\n                'name': current_term.name,\n                'distance': current_distance,\n            }\n        ]\n        try:\n            parents = [\n                p\n                for p in current_term.superclasses(distance=1)\n                if p.id != current_term.id\n            ]\n        except (AttributeError, TypeError) as e:\n            logger.error(\n                f\"Error retrieving superclasses for term '{current_term.id}': {e}\"\n            )\n            return\n        if not parents:\n            # Reached root, save this path\n            trajectories.append(path[::-1])\n            return\n        for parent in parents:\n            dfs(\n                parent,\n                current_distance - 1,\n                path,\n                visited | {current_term.id},\n            )\n\n    dfs(term, 0, [], set())\n    return trajectories\n</code></pre>"},{"location":"reference/source/ontograph/queries/introspection/#ontograph.queries.introspection.IntrospectionPronto.print_term_trajectories_tree","title":"<code>print_term_trajectories_tree(trajectories)</code>  <code>staticmethod</code>","text":"<p>Print all ancestor trajectories as a single ASCII tree from root to the original term.</p> <p>For a single trajectory, print each node as '{id}: {name}'. For multiple, print as ASCII tree.</p> Source code in <code>ontograph/queries/introspection.py</code> <pre><code>@staticmethod\ndef print_term_trajectories_tree(trajectories: list[dict]) -&gt; None:\n    \"\"\"Print all ancestor trajectories as a single ASCII tree from root to the original term.\n\n    For a single trajectory, print each node as '{id}: {name}'.\n    For multiple, print as ASCII tree.\n    \"\"\"\n    if not trajectories:\n        print('No trajectories to display.')\n        return\n    # If only one trajectory, print each node simply\n    if len(trajectories) == 1:\n        for node in trajectories[0]:\n            print(f'{node[\"id\"]}: {node[\"name\"]}')\n        return\n    # Otherwise, use tree printing\n    root = IntrospectionOntology._build_tree_from_trajectories(trajectories)\n    IntrospectionOntology._print_ascii_tree(root)\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/","title":"queries.navigator","text":"<p>This module provides the <code>OntologyNavigator</code> class for traversing and querying ontology term relationships.</p>"},{"location":"reference/source/ontograph/queries/navigator/#api-reference","title":"API Reference","text":""},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas","title":"<code>NavigatorGraphblas</code>","text":"<p>               Bases: <code>NavigatorOntology</code></p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>class NavigatorGraphblas(NavigatorOntology):\n    def __init__(self, ontology: Ontology, lookup_tables: LookUpTables) -&gt; None:\n        self.__ontology = ontology\n\n        # --- Nodes ---\n        self.nodes_indexes = self.__ontology.nodes_indexes\n        self.nodes_dataframe = self.__ontology.nodes_dataframe\n        # --- Edges ---\n        self.edges_indexes = self.__ontology.edges_indexes\n        self.edges_dataframe = self.__ontology.edges_dataframe\n\n        # --- Lookup Tables ---\n        self.lookup_tables = lookup_tables\n        self.number_nodes = self.__ontology.number_nodes\n        self.number_edges = self.__ontology.number_edges\n\n        self.matrices_container = self.__ontology.matrices_container\n\n    def one_hot_vector(self, index: int) -&gt; gb.Vector:\n        return gb.Vector.from_coo(\n            [index], [1], size=self.number_nodes, dtype=int\n        )\n\n    def _traverse_graph(\n        self,\n        term_id: str,\n        adjacency_matrix: gb.Matrix,\n        distance: int = None,\n        include_self: bool = False,\n    ) -&gt; list:\n        \"\"\"Generalized function to traverse a graph in either direction.\n\n        Parameters\n        ----------\n        term_id : str\n            The starting term ID.\n        adjacency_matrix : gb.Matrix\n            Adjacency matrix to traverse (forward for descendants, transposed for ancestors).\n        distance : int or None\n            Maximum distance to traverse. None means unlimited.\n        include_self : bool\n            Whether to include the starting node in the result.\n\n        Returns:\n        -------\n        List[str]\n            List of term IDs reached.\n        \"\"\"\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        index = self.lookup_tables.term_to_index(term_id)\n        current_vector = self.one_hot_vector(index=index)\n        visited = set()\n\n        if include_self:\n            visited.add(index)\n\n        while current_vector.nvals != 0 and distance != 0:\n            next_vector = gb.Vector(dtype=int, size=adjacency_matrix.nrows)\n            next_vector &lt;&lt; gb.semiring.plus_times(\n                adjacency_matrix @ current_vector\n            )  # forward or transposed depends on matrix\n\n            next_indices = set(next_vector.to_coo()[0])\n            next_indices.difference_update(visited)\n\n            if not next_indices:\n                break\n\n            visited.update(next_indices)\n            current_vector = gb.Vector.from_coo(\n                list(next_indices),\n                [1] * len(next_indices),\n                size=adjacency_matrix.nrows,\n            )\n\n            if distance is not None:\n                distance -= 1\n\n        return self.lookup_tables.index_to_term(list(visited))\n\n    def _traverse_graph_with_distance(\n        self,\n        term_id: str,\n        adjacency_matrix: gb.Matrix,\n        include_self: bool = False,\n    ) -&gt; list:\n        \"\"\"Generalized function to traverse a graph and return nodes with distance from start.\n\n        Parameters\n        ----------\n        term_id : str\n            The starting term ID.\n        adjacency_matrix : gb.Matrix\n            Adjacency matrix to traverse (forward for descendants, transposed for ancestors).\n        include_self : bool\n            Whether to include the starting node with distance 0.\n\n        Returns:\n        -------\n        List[Tuple[int, int]]\n            List of tuples (node_index, distance_from_start)\n        \"\"\"\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        start_index = self.lookup_tables.term_to_index(term_id)\n        current_vector = self.one_hot_vector(index=start_index)\n\n        distances = {}  # {node_index: distance}\n        distance_counter = 0\n\n        if include_self:\n            distances[start_index] = 0\n\n        while current_vector.nvals != 0:\n            next_vector = gb.Vector(dtype=int, size=adjacency_matrix.nrows)\n            next_vector &lt;&lt; gb.semiring.plus_times(\n                adjacency_matrix @ current_vector\n            )\n\n            next_indices = set(next_vector.to_coo()[0])\n            # remove already visited nodes\n            next_indices.difference_update(distances.keys())\n\n            if not next_indices:\n                break\n\n            distance_counter += 1\n            for idx in next_indices:\n                distances[idx] = distance_counter\n\n            current_vector = gb.Vector.from_coo(\n                list(next_indices),\n                [1] * len(next_indices),\n                size=adjacency_matrix.nrows,\n            )\n\n        # return as list of tuples\n        return [\n            (self.lookup_tables.index_to_term(int(index)), distance)\n            for index, distance in distances.items()\n        ]\n\n    # -- get_parents(term_id, include_self=False)\n    def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n        # Validate and resolve the index\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        index = self.lookup_tables.term_to_index(term_id)\n\n        # Initialize a one-hot vector for the term node\n        vector_node = self.one_hot_vector(index=index)\n\n        # Propagate to parents using matrix-vector multiplication\n        parent_vec = (self.matrices_container['is_a'].T @ vector_node).new()\n\n        # Extract parent indices efficiently\n        parent_indices = set(parent_vec.to_coo()[0])\n        if include_self:\n            parent_indices.add(index)\n\n        # Convert indices to term IDs\n        return self.lookup_tables.index_to_term(list(parent_indices))\n\n    # -- get_root()\n    def get_root(self) -&gt; list:\n        matrix = self.matrices_container['is_a'].T\n\n        # 1. Compute the number of incoming edges per node (column-wise sum)\n        col_sums_expr = matrix.reduce_columnwise(gb.binary.plus)\n\n        # 2. Materialize the VectorExpression\n        col_sums_vec = col_sums_expr.new()\n\n        # 3. Extract non-zero indices and their counts\n        indices, values = col_sums_vec.to_coo()\n\n        # 4. Create dense array of incoming edge counts\n        col_sums_np = np.zeros(matrix.ncols, dtype=np.int64)\n        col_sums_np[indices] = values\n\n        # 5. Roots = nodes with zero incoming edges\n        roots = np.where(col_sums_np == 0)[0]\n\n        return self.lookup_tables.index_to_term(roots)\n\n    def get_term(self, term_id: str) -&gt; object:\n        \"\"\"Retrieve the ontology term object for a given term ID.\"\"\"\n        pass\n\n    # -- get_children(term_id, include_self=False)\n    def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n        # validate and resolve the index\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        index = self.lookup_tables.term_to_index(term_id)\n\n        # Initialize a one-hot vector for the term node\n        vector_node = self.one_hot_vector(index=index)\n\n        # Propagate to children using matrix-vector multiplication\n        children_vec = (self.matrices_container['is_a'] @ vector_node).new()\n\n        # Optionally include the node itself\n        if include_self:\n            children_vec[index] = True\n\n        # translate indexes to terms\n        terms = list(children_vec)\n\n        return self.lookup_tables.index_to_term(terms)\n\n    def get_ancestors(\n        self, term_id: str, distance: int = None, include_self: bool = False\n    ) -&gt; list:\n        adjacency_matrix = self.matrices_container[\n            'is_a'\n        ].T  # transpose for ancestors\n        return self._traverse_graph(\n            term_id, adjacency_matrix, distance, include_self\n        )\n\n    def get_ancestors_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; list:\n        adjacency_matrix = self.matrices_container[\n            'is_a'\n        ].T  # transpose for ancestors\n        return self._traverse_graph_with_distance(\n            term_id, adjacency_matrix, include_self\n        )\n\n    def get_descendants(\n        self, term_id: str, distance: int = None, include_self: bool = False\n    ) -&gt; list:\n        adjacency_matrix = self.matrices_container[\n            'is_a'\n        ]  # normal direction for descendants\n        return self._traverse_graph(\n            term_id, adjacency_matrix, distance, include_self\n        )\n\n    def get_descendants_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; list:\n        adjacency_matrix = self.matrices_container[\n            'is_a'\n        ]  # normal direction for descendants\n        return self._traverse_graph_with_distance(\n            term_id, adjacency_matrix, include_self\n        )\n\n    def get_siblings(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; list[str]:\n        \"\"\"Retrieve all siblings of a given term (i.e., nodes that share at least one parent).\n\n        Parameters\n        ----------\n        term_id : str\n            The term ID whose siblings are to be found.\n        include_self : bool, optional (default=False)\n            Whether to include the term itself in the returned set.\n\n        Returns:\n        -------\n        List[str]\n            List of sibling term IDs.\n        \"\"\"\n        # Validate term existence\n        if term_id not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {term_id}')\n\n        # Step 1: Get parents of the given term\n        parents = self.get_parents(term_id, include_self=False)\n        if not parents:\n            # No parents means this term is a root -&gt; no siblings\n            return []\n\n        # Step 2: For each parent, get its children\n        siblings_set = set()\n        for parent_id in parents:\n            children = self.get_children(parent_id, include_self=False)\n            siblings_set.update(children)\n\n        # Step 3: Optionally remove the term itself\n        if not include_self and term_id in siblings_set:\n            siblings_set.remove(term_id)\n\n        # Return as sorted list for deterministic output\n        return sorted(siblings_set)\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas.get_siblings","title":"<code>get_siblings(term_id, include_self=False)</code>","text":"<p>Retrieve all siblings of a given term (i.e., nodes that share at least one parent).</p>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas.get_siblings--parameters","title":"Parameters","text":"<p>term_id : str     The term ID whose siblings are to be found. include_self : bool, optional (default=False)     Whether to include the term itself in the returned set.</p>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas.get_siblings--returns","title":"Returns:","text":"<p>List[str]     List of sibling term IDs.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_siblings(\n    self, term_id: str, include_self: bool = False\n) -&gt; list[str]:\n    \"\"\"Retrieve all siblings of a given term (i.e., nodes that share at least one parent).\n\n    Parameters\n    ----------\n    term_id : str\n        The term ID whose siblings are to be found.\n    include_self : bool, optional (default=False)\n        Whether to include the term itself in the returned set.\n\n    Returns:\n    -------\n    List[str]\n        List of sibling term IDs.\n    \"\"\"\n    # Validate term existence\n    if term_id not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {term_id}')\n\n    # Step 1: Get parents of the given term\n    parents = self.get_parents(term_id, include_self=False)\n    if not parents:\n        # No parents means this term is a root -&gt; no siblings\n        return []\n\n    # Step 2: For each parent, get its children\n    siblings_set = set()\n    for parent_id in parents:\n        children = self.get_children(parent_id, include_self=False)\n        siblings_set.update(children)\n\n    # Step 3: Optionally remove the term itself\n    if not include_self and term_id in siblings_set:\n        siblings_set.remove(term_id)\n\n    # Return as sorted list for deterministic output\n    return sorted(siblings_set)\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorGraphblas.get_term","title":"<code>get_term(term_id)</code>","text":"<p>Retrieve the ontology term object for a given term ID.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_term(self, term_id: str) -&gt; object:\n    \"\"\"Retrieve the ontology term object for a given term ID.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology","title":"<code>NavigatorOntology</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract navigator for traversing and querying ontology term relationships.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>class NavigatorOntology(ABC):\n    \"\"\"Abstract navigator for traversing and querying ontology term relationships.\"\"\"\n\n    def __init__(self, ontology: 'Ontology') -&gt; None:\n        self._ontology = ontology.get_ontology()\n\n    @abstractmethod\n    def get_term(self, term_id: str) -&gt; object:\n        \"\"\"Retrieve the ontology term object for a given term ID.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Retrieve the parent term IDs (superclasses) of a given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Retrieve the child term IDs (subclasses) of a given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_ancestors(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; list[str]:\n        \"\"\"Retrieve all ancestor term IDs (superclasses) of a given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_ancestors_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; 'Iterator[tuple[object, int]]':\n        \"\"\"Retrieve all ancestor terms with their distance from the given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_descendants(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; set[str]:\n        \"\"\"Retrieve all descendant term IDs (subclasses) of a given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_descendants_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; 'Iterator[tuple[object, int]]':\n        \"\"\"Retrieve all descendant terms with their distance from the given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_siblings(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; set[str]:\n        \"\"\"Retrieve the sibling term IDs of a given term.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_root(self) -&gt; list:\n        \"\"\"Returns the root term(s) of the ontology \u2014 terms with no superclasses.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_ancestors","title":"<code>get_ancestors(term_id, distance=None, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve all ancestor term IDs (superclasses) of a given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_ancestors(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; list[str]:\n    \"\"\"Retrieve all ancestor term IDs (superclasses) of a given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_ancestors_with_distance","title":"<code>get_ancestors_with_distance(term_id, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve all ancestor terms with their distance from the given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_ancestors_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; 'Iterator[tuple[object, int]]':\n    \"\"\"Retrieve all ancestor terms with their distance from the given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_children","title":"<code>get_children(term_id, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the child term IDs (subclasses) of a given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Retrieve the child term IDs (subclasses) of a given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_descendants","title":"<code>get_descendants(term_id, distance=None, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve all descendant term IDs (subclasses) of a given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_descendants(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; set[str]:\n    \"\"\"Retrieve all descendant term IDs (subclasses) of a given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_descendants_with_distance","title":"<code>get_descendants_with_distance(term_id, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve all descendant terms with their distance from the given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_descendants_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; 'Iterator[tuple[object, int]]':\n    \"\"\"Retrieve all descendant terms with their distance from the given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_parents","title":"<code>get_parents(term_id, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the parent term IDs (superclasses) of a given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Retrieve the parent term IDs (superclasses) of a given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_root","title":"<code>get_root()</code>  <code>abstractmethod</code>","text":"<p>Returns the root term(s) of the ontology \u2014 terms with no superclasses.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_root(self) -&gt; list:\n    \"\"\"Returns the root term(s) of the ontology \u2014 terms with no superclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_siblings","title":"<code>get_siblings(term_id, include_self=False)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the sibling term IDs of a given term.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_siblings(\n    self, term_id: str, include_self: bool = False\n) -&gt; set[str]:\n    \"\"\"Retrieve the sibling term IDs of a given term.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorOntology.get_term","title":"<code>get_term(term_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve the ontology term object for a given term ID.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>@abstractmethod\ndef get_term(self, term_id: str) -&gt; object:\n    \"\"\"Retrieve the ontology term object for a given term ID.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto","title":"<code>NavigatorPronto</code>","text":"<p>               Bases: <code>NavigatorOntology</code></p> <p>Navigator for traversing and querying ontology term relationships.</p> <p>This class provides methods to retrieve parent, ancestor, descendant, sibling, and root terms from an ontology loaded via the Ontology model. It is designed to facilitate graph-like navigation of ontology structures, supporting queries for hierarchical relationships.</p> <p>Attributes:</p> Name Type Description <code>__ontology</code> <p>The underlying ontology object.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>class NavigatorPronto(NavigatorOntology):\n    \"\"\"Navigator for traversing and querying ontology term relationships.\n\n    This class provides methods to retrieve parent, ancestor, descendant, sibling, and root terms\n    from an ontology loaded via the Ontology model. It is designed to facilitate graph-like navigation\n    of ontology structures, supporting queries for hierarchical relationships.\n\n    Attributes:\n        __ontology: The underlying ontology object.\n    \"\"\"\n\n    def __init__(self, ontology: Ontology) -&gt; None:\n        \"\"\"Initializes the OntologyNavigator.\n\n        Args:\n            ontology (Ontology): An Ontology object containing the loaded ontology data.\n        \"\"\"\n        self.__ontology = ontology.get_ontology()\n\n    def get_term(self, term_id: str) -&gt; object:\n        \"\"\"Retrieves the ontology term object for a given term ID.\n\n        Args:\n            term_id (str): The identifier of the ontology term.\n\n        Returns:\n            pronto.Term: The ontology term object corresponding to the given ID.\n\n        Raises:\n            KeyError: If the term_id is not found in the ontology.\n        \"\"\"\n        try:\n            return self.__ontology[term_id]\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            raise\n\n    def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Retrieves the parent term IDs (superclasses) of a given term.\n\n        Args:\n            term_id (str): The identifier of the term whose parents are to be retrieved.\n            include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n        Returns:\n            list: A list of parent term IDs.\n        \"\"\"\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return []\n\n        try:\n            parents = [\n                parent.id\n                for parent in term.superclasses(\n                    distance=1, with_self=include_self\n                )\n            ]\n            logger.debug(f'parents: {parents}')\n            return parents\n        except Exception as e:\n            logger.exception(\n                f\"Error retrieving parents for term '{term_id}': {e}\"\n            )\n            return []\n\n    def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n        \"\"\"Retrieves the child term IDs (subclasses) of a given term.\n\n        Args:\n            term_id (str): The identifier of the term whose children are to be retrieved.\n            include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n        Returns:\n            list: A list of child term IDs.\n\n        Raises:\n            KeyError: If the term_id is not found in the ontology.\n        \"\"\"\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return []\n\n        try:\n            children = [\n                child.id\n                for child in term.subclasses(distance=1, with_self=include_self)\n            ]\n            logger.debug(f'children: {children}')\n            return children\n        except Exception as e:\n            logger.exception(\n                f\"Error retrieving children for term '{term_id}': {e}\"\n            )\n            return []\n\n    def get_ancestors(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; list[str]:\n        \"\"\"Retrieve all ancestor term IDs (superclasses) of a given term.\n\n        Args:\n            term_id (str): The identifier of the term whose ancestors are to be retrieved.\n            distance (int | None, optional): The maximum distance to traverse up the hierarchy. If None, retrieves all ancestors. Defaults to None.\n            include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n        Returns:\n            set[str]: A list of ancestor term IDs. None in case of having no ancestors.\n\n        Raises:\n            KeyError: If the term_id is not found in the ontology.\n            Exception: If an error occurs during ancestor retrieval.\n        \"\"\"\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return []\n\n        try:\n            ancestor_terms = term.superclasses(\n                distance=distance, with_self=include_self\n            )\n            ancestor_ids = [ancestor.id for ancestor in ancestor_terms]\n            logger.debug(f\"Ancestors of term '{term_id}': {ancestor_ids}\")\n            return ancestor_ids\n        except Exception as e:\n            logger.exception(\n                f\"Error retrieving ancestors for term '{term_id}': {e}\"\n            )\n            return []\n\n    def get_ancestors_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; Iterator[tuple[object, int]]:\n        \"\"\"Retrieve all ancestor terms with their distance from the given term.\n\n        Args:\n            term_id (str): The identifier of the ontology term.\n            include_self (bool): Whether to include the term itself at distance 0.\n\n        Returns:\n            Iterator(tuple[Term, int]): Pairs of ancestor term objects and their distance (negative integer).\n\n        Raises:\n            KeyError: If the term is not found in the ontology.\n        \"\"\"\n\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return iter(())\n\n        visited = set()\n        queue = deque()\n\n        if include_self:\n            queue.append((term, 0))\n        else:\n            for parent in term.superclasses(distance=1):\n                if parent.id != term.id:\n                    queue.append((parent, -1))\n\n        while queue:\n            current_term, dist = queue.popleft()\n            if current_term.id in visited:\n                continue\n\n            visited.add(current_term.id)\n            yield current_term, dist\n\n            for parent in current_term.superclasses(distance=1):\n                if parent.id not in visited and parent.id != current_term.id:\n                    queue.append((parent, dist - 1))\n\n    def get_descendants(\n        self,\n        term_id: str,\n        distance: int | None = None,\n        include_self: bool = False,\n    ) -&gt; set[str]:\n        \"\"\"Retrieve all descendant term IDs (subclasses) of a given term.\n\n        Args:\n            term_id (str): The identifier of the term whose descendants are to be retrieved.\n            distance (int | None, optional): The maximum distance to traverse down the hierarchy. If None, retrieves all descendants. Defaults to None.\n            include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n        Returns:\n            set[str]: A set of descendant term IDs.\n\n        Raises:\n            KeyError: If the term_id is not found in the ontology.\n            Exception: If an error occurs during descendant retrieval.\n        \"\"\"\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return set()\n\n        try:\n            descendant_ids = {\n                descendant.id\n                for descendant in term.subclasses(distance=distance)\n            }\n            if not include_self and term.id in descendant_ids:\n                descendant_ids.remove(term.id)\n            logger.debug(f\"Descendants of term '{term_id}': {descendant_ids}\")\n            return descendant_ids\n        except Exception as e:\n            logger.exception(\n                f\"Error retrieving descendants for term '{term_id}': {e}\"\n            )\n            return set()\n\n    def get_descendants_with_distance(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; Iterator[tuple[object, int]]:\n        \"\"\"Retrieve all descendant terms with their distance from the given term.\n\n        Args:\n            term_id (str): The identifier of the ontology term.\n            include_self (bool): Whether to include the term itself at distance 0.\n\n        Returns:\n            Iterator[tuple[Term, int]]: Generator of (descendant term, distance) pairs. Distance in positive numbers.\n\n        Raises:\n            KeyError: If the term ID is not found in the ontology.\n        \"\"\"\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return iter(())\n\n        visited = set()\n        queue = deque()\n\n        if include_self:\n            queue.append((term, 0))\n        else:\n            for child in term.subclasses(distance=1):\n                if child.id != term.id:\n                    queue.append((child, 1))\n\n        while queue:\n            current_term, dist = queue.popleft()\n            if current_term.id in visited:\n                continue\n\n            visited.add(current_term.id)\n            yield current_term, dist\n\n            for child in current_term.subclasses(distance=1):\n                if child.id not in visited and child.id != current_term.id:\n                    queue.append((child, dist + 1))\n\n    def get_siblings(\n        self, term_id: str, include_self: bool = False\n    ) -&gt; set[str]:\n        \"\"\"Retrieve the sibling term IDs of a given term.\n\n        Siblings are terms that share at least one direct parent (superclass) with the given term.\n\n        Args:\n            term_id (str): The identifier of the ontology term.\n            include_self (bool): Whether to include the term itself in the result.\n\n        Returns:\n            set[str]: A set of sibling term IDs.\n\n        Raises:\n            KeyError: If the term_id is not found in the ontology.\n            Exception: If an error occurs during sibling retrieval.\n        \"\"\"\n        logger.debug(f'Siblings for term: {term_id}')\n\n        try:\n            term = self.get_term(term_id)\n        except KeyError:\n            logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n            return set()\n\n        siblings = set()\n        try:\n            for parent in term.superclasses(distance=1, with_self=False):\n                logger.debug(f'parent: {parent.id}')\n                for child in parent.subclasses(distance=1, with_self=False):\n                    logger.debug(f'child found: {child.id}')\n                    siblings.add(child.id)\n\n            if not include_self and term_id in siblings:\n                siblings.remove(term_id)\n\n            return siblings\n        except Exception as e:\n            logger.exception(\n                f\"Error retrieving siblings for term '{term_id}': {e}\"\n            )\n            return set()\n\n    def get_root(self) -&gt; list:\n        \"\"\"Returns the root term(s) of the ontology \u2014 terms with no superclasses.\n\n        Returns:\n            list: A list of root term objects.\n\n        Raises:\n            Exception: If an error occurs during root term retrieval.\n        \"\"\"\n        try:\n            root_terms = []\n\n            for term in self.__ontology.terms():\n                if (\n                    not term.obsolete\n                    and len(\n                        list(term.superclasses(distance=1, with_self=False))\n                    )\n                    == 0\n                ):\n                    root_terms.append(term)\n            return root_terms\n        except Exception as e:\n            logger.exception(f'Error retrieving root terms: {e}')\n            return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.__init__","title":"<code>__init__(ontology)</code>","text":"<p>Initializes the OntologyNavigator.</p> <p>Parameters:</p> Name Type Description Default <code>ontology</code> <code>Ontology</code> <p>An Ontology object containing the loaded ontology data.</p> required Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def __init__(self, ontology: Ontology) -&gt; None:\n    \"\"\"Initializes the OntologyNavigator.\n\n    Args:\n        ontology (Ontology): An Ontology object containing the loaded ontology data.\n    \"\"\"\n    self.__ontology = ontology.get_ontology()\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_ancestors","title":"<code>get_ancestors(term_id, distance=None, include_self=False)</code>","text":"<p>Retrieve all ancestor term IDs (superclasses) of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term whose ancestors are to be retrieved.</p> required <code>distance</code> <code>int | None</code> <p>The maximum distance to traverse up the hierarchy. If None, retrieves all ancestors. Defaults to None.</p> <code>None</code> <code>include_self</code> <code>bool</code> <p>If True, include the term itself in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>set[str]: A list of ancestor term IDs. None in case of having no ancestors.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term_id is not found in the ontology.</p> <code>Exception</code> <p>If an error occurs during ancestor retrieval.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_ancestors(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; list[str]:\n    \"\"\"Retrieve all ancestor term IDs (superclasses) of a given term.\n\n    Args:\n        term_id (str): The identifier of the term whose ancestors are to be retrieved.\n        distance (int | None, optional): The maximum distance to traverse up the hierarchy. If None, retrieves all ancestors. Defaults to None.\n        include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n    Returns:\n        set[str]: A list of ancestor term IDs. None in case of having no ancestors.\n\n    Raises:\n        KeyError: If the term_id is not found in the ontology.\n        Exception: If an error occurs during ancestor retrieval.\n    \"\"\"\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return []\n\n    try:\n        ancestor_terms = term.superclasses(\n            distance=distance, with_self=include_self\n        )\n        ancestor_ids = [ancestor.id for ancestor in ancestor_terms]\n        logger.debug(f\"Ancestors of term '{term_id}': {ancestor_ids}\")\n        return ancestor_ids\n    except Exception as e:\n        logger.exception(\n            f\"Error retrieving ancestors for term '{term_id}': {e}\"\n        )\n        return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_ancestors_with_distance","title":"<code>get_ancestors_with_distance(term_id, include_self=False)</code>","text":"<p>Retrieve all ancestor terms with their distance from the given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the ontology term.</p> required <code>include_self</code> <code>bool</code> <p>Whether to include the term itself at distance 0.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>tuple[Term, int]</code> <p>Pairs of ancestor term objects and their distance (negative integer).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term is not found in the ontology.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_ancestors_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; Iterator[tuple[object, int]]:\n    \"\"\"Retrieve all ancestor terms with their distance from the given term.\n\n    Args:\n        term_id (str): The identifier of the ontology term.\n        include_self (bool): Whether to include the term itself at distance 0.\n\n    Returns:\n        Iterator(tuple[Term, int]): Pairs of ancestor term objects and their distance (negative integer).\n\n    Raises:\n        KeyError: If the term is not found in the ontology.\n    \"\"\"\n\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return iter(())\n\n    visited = set()\n    queue = deque()\n\n    if include_self:\n        queue.append((term, 0))\n    else:\n        for parent in term.superclasses(distance=1):\n            if parent.id != term.id:\n                queue.append((parent, -1))\n\n    while queue:\n        current_term, dist = queue.popleft()\n        if current_term.id in visited:\n            continue\n\n        visited.add(current_term.id)\n        yield current_term, dist\n\n        for parent in current_term.superclasses(distance=1):\n            if parent.id not in visited and parent.id != current_term.id:\n                queue.append((parent, dist - 1))\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_children","title":"<code>get_children(term_id, include_self=False)</code>","text":"<p>Retrieves the child term IDs (subclasses) of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term whose children are to be retrieved.</p> required <code>include_self</code> <code>bool</code> <p>If True, include the term itself in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of child term IDs.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term_id is not found in the ontology.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_children(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Retrieves the child term IDs (subclasses) of a given term.\n\n    Args:\n        term_id (str): The identifier of the term whose children are to be retrieved.\n        include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n    Returns:\n        list: A list of child term IDs.\n\n    Raises:\n        KeyError: If the term_id is not found in the ontology.\n    \"\"\"\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return []\n\n    try:\n        children = [\n            child.id\n            for child in term.subclasses(distance=1, with_self=include_self)\n        ]\n        logger.debug(f'children: {children}')\n        return children\n    except Exception as e:\n        logger.exception(\n            f\"Error retrieving children for term '{term_id}': {e}\"\n        )\n        return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_descendants","title":"<code>get_descendants(term_id, distance=None, include_self=False)</code>","text":"<p>Retrieve all descendant term IDs (subclasses) of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term whose descendants are to be retrieved.</p> required <code>distance</code> <code>int | None</code> <p>The maximum distance to traverse down the hierarchy. If None, retrieves all descendants. Defaults to None.</p> <code>None</code> <code>include_self</code> <code>bool</code> <p>If True, include the term itself in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: A set of descendant term IDs.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term_id is not found in the ontology.</p> <code>Exception</code> <p>If an error occurs during descendant retrieval.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_descendants(\n    self,\n    term_id: str,\n    distance: int | None = None,\n    include_self: bool = False,\n) -&gt; set[str]:\n    \"\"\"Retrieve all descendant term IDs (subclasses) of a given term.\n\n    Args:\n        term_id (str): The identifier of the term whose descendants are to be retrieved.\n        distance (int | None, optional): The maximum distance to traverse down the hierarchy. If None, retrieves all descendants. Defaults to None.\n        include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n    Returns:\n        set[str]: A set of descendant term IDs.\n\n    Raises:\n        KeyError: If the term_id is not found in the ontology.\n        Exception: If an error occurs during descendant retrieval.\n    \"\"\"\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return set()\n\n    try:\n        descendant_ids = {\n            descendant.id\n            for descendant in term.subclasses(distance=distance)\n        }\n        if not include_self and term.id in descendant_ids:\n            descendant_ids.remove(term.id)\n        logger.debug(f\"Descendants of term '{term_id}': {descendant_ids}\")\n        return descendant_ids\n    except Exception as e:\n        logger.exception(\n            f\"Error retrieving descendants for term '{term_id}': {e}\"\n        )\n        return set()\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_descendants_with_distance","title":"<code>get_descendants_with_distance(term_id, include_self=False)</code>","text":"<p>Retrieve all descendant terms with their distance from the given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the ontology term.</p> required <code>include_self</code> <code>bool</code> <p>Whether to include the term itself at distance 0.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[tuple[object, int]]</code> <p>Iterator[tuple[Term, int]]: Generator of (descendant term, distance) pairs. Distance in positive numbers.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term ID is not found in the ontology.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_descendants_with_distance(\n    self, term_id: str, include_self: bool = False\n) -&gt; Iterator[tuple[object, int]]:\n    \"\"\"Retrieve all descendant terms with their distance from the given term.\n\n    Args:\n        term_id (str): The identifier of the ontology term.\n        include_self (bool): Whether to include the term itself at distance 0.\n\n    Returns:\n        Iterator[tuple[Term, int]]: Generator of (descendant term, distance) pairs. Distance in positive numbers.\n\n    Raises:\n        KeyError: If the term ID is not found in the ontology.\n    \"\"\"\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return iter(())\n\n    visited = set()\n    queue = deque()\n\n    if include_self:\n        queue.append((term, 0))\n    else:\n        for child in term.subclasses(distance=1):\n            if child.id != term.id:\n                queue.append((child, 1))\n\n    while queue:\n        current_term, dist = queue.popleft()\n        if current_term.id in visited:\n            continue\n\n        visited.add(current_term.id)\n        yield current_term, dist\n\n        for child in current_term.subclasses(distance=1):\n            if child.id not in visited and child.id != current_term.id:\n                queue.append((child, dist + 1))\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_parents","title":"<code>get_parents(term_id, include_self=False)</code>","text":"<p>Retrieves the parent term IDs (superclasses) of a given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the term whose parents are to be retrieved.</p> required <code>include_self</code> <code>bool</code> <p>If True, include the term itself in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of parent term IDs.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_parents(self, term_id: str, include_self: bool = False) -&gt; list:\n    \"\"\"Retrieves the parent term IDs (superclasses) of a given term.\n\n    Args:\n        term_id (str): The identifier of the term whose parents are to be retrieved.\n        include_self (bool, optional): If True, include the term itself in the result. Defaults to False.\n\n    Returns:\n        list: A list of parent term IDs.\n    \"\"\"\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return []\n\n    try:\n        parents = [\n            parent.id\n            for parent in term.superclasses(\n                distance=1, with_self=include_self\n            )\n        ]\n        logger.debug(f'parents: {parents}')\n        return parents\n    except Exception as e:\n        logger.exception(\n            f\"Error retrieving parents for term '{term_id}': {e}\"\n        )\n        return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_root","title":"<code>get_root()</code>","text":"<p>Returns the root term(s) of the ontology \u2014 terms with no superclasses.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of root term objects.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during root term retrieval.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_root(self) -&gt; list:\n    \"\"\"Returns the root term(s) of the ontology \u2014 terms with no superclasses.\n\n    Returns:\n        list: A list of root term objects.\n\n    Raises:\n        Exception: If an error occurs during root term retrieval.\n    \"\"\"\n    try:\n        root_terms = []\n\n        for term in self.__ontology.terms():\n            if (\n                not term.obsolete\n                and len(\n                    list(term.superclasses(distance=1, with_self=False))\n                )\n                == 0\n            ):\n                root_terms.append(term)\n        return root_terms\n    except Exception as e:\n        logger.exception(f'Error retrieving root terms: {e}')\n        return []\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_siblings","title":"<code>get_siblings(term_id, include_self=False)</code>","text":"<p>Retrieve the sibling term IDs of a given term.</p> <p>Siblings are terms that share at least one direct parent (superclass) with the given term.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the ontology term.</p> required <code>include_self</code> <code>bool</code> <p>Whether to include the term itself in the result.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: A set of sibling term IDs.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term_id is not found in the ontology.</p> <code>Exception</code> <p>If an error occurs during sibling retrieval.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_siblings(\n    self, term_id: str, include_self: bool = False\n) -&gt; set[str]:\n    \"\"\"Retrieve the sibling term IDs of a given term.\n\n    Siblings are terms that share at least one direct parent (superclass) with the given term.\n\n    Args:\n        term_id (str): The identifier of the ontology term.\n        include_self (bool): Whether to include the term itself in the result.\n\n    Returns:\n        set[str]: A set of sibling term IDs.\n\n    Raises:\n        KeyError: If the term_id is not found in the ontology.\n        Exception: If an error occurs during sibling retrieval.\n    \"\"\"\n    logger.debug(f'Siblings for term: {term_id}')\n\n    try:\n        term = self.get_term(term_id)\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        return set()\n\n    siblings = set()\n    try:\n        for parent in term.superclasses(distance=1, with_self=False):\n            logger.debug(f'parent: {parent.id}')\n            for child in parent.subclasses(distance=1, with_self=False):\n                logger.debug(f'child found: {child.id}')\n                siblings.add(child.id)\n\n        if not include_self and term_id in siblings:\n            siblings.remove(term_id)\n\n        return siblings\n    except Exception as e:\n        logger.exception(\n            f\"Error retrieving siblings for term '{term_id}': {e}\"\n        )\n        return set()\n</code></pre>"},{"location":"reference/source/ontograph/queries/navigator/#ontograph.queries.navigator.NavigatorPronto.get_term","title":"<code>get_term(term_id)</code>","text":"<p>Retrieves the ontology term object for a given term ID.</p> <p>Parameters:</p> Name Type Description Default <code>term_id</code> <code>str</code> <p>The identifier of the ontology term.</p> required <p>Returns:</p> Type Description <code>object</code> <p>pronto.Term: The ontology term object corresponding to the given ID.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the term_id is not found in the ontology.</p> Source code in <code>ontograph/queries/navigator.py</code> <pre><code>def get_term(self, term_id: str) -&gt; object:\n    \"\"\"Retrieves the ontology term object for a given term ID.\n\n    Args:\n        term_id (str): The identifier of the ontology term.\n\n    Returns:\n        pronto.Term: The ontology term object corresponding to the given ID.\n\n    Raises:\n        KeyError: If the term_id is not found in the ontology.\n    \"\"\"\n    try:\n        return self.__ontology[term_id]\n    except KeyError:\n        logger.exception(f\"Term ID '{term_id}' not found in ontology.\")\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/","title":"queries.relations","text":"<p>This module provides the <code>OntologyRelations</code> class for querying relationships between ontology terms.</p>"},{"location":"reference/source/ontograph/queries/relations/#api-reference","title":"API Reference","text":""},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations-classes","title":"Classes","text":""},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas","title":"<code>RelationsGraphblas</code>","text":"<p>               Bases: <code>RelationsOntology</code></p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>class RelationsGraphblas(RelationsOntology):\n    def __init__(\n        self, navigator: _OntologyNavigator, lookup_tables: object\n    ) -&gt; None:\n        \"\"\"Initialize OntologyRelations.\n\n        Args:\n            navigator (_OntologyNavigator): The ontology navigator instance.\n            lookup_tables (object): Lookup tables for term indices and relationships.\n        \"\"\"\n        self.__navigator = navigator\n        self.lookup_tables = lookup_tables\n\n    def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n        \"\"\"Check if `ancestor_node` is an ancestor of `descendant_node`.\n\n        Parameters\n        ----------\n        ancestor_node : str\n            Candidate ancestor term ID.\n        descendant_node : str\n            Candidate descendant term ID.\n\n        Returns:\n        -------\n        bool\n            True if `ancestor_node` is an ancestor of `descendant_node`, else False.\n        \"\"\"\n        if descendant_node not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {descendant_node}')\n        if ancestor_node not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {ancestor_node}')\n\n        # Retrieve ancestors of the descendant\n        ancestors = set(\n            self.__navigator.get_ancestors(descendant_node, include_self=False)\n        )\n        return ancestor_node in ancestors\n\n    def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n        \"\"\"Check if `descendant_node` is a descendant of `ancestor_node`.\n\n        Parameters\n        ----------\n        descendant_node : str\n            Candidate descendant term ID.\n        ancestor_node : str\n            Candidate ancestor term ID.\n\n        Returns:\n        -------\n        bool\n            True if `descendant_node` is a descendant of `ancestor_node`, else False.\n        \"\"\"\n        if ancestor_node not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {ancestor_node}')\n        if descendant_node not in self.lookup_tables.get_lut_term_to_index():\n            raise KeyError(f'Unknown term ID: {descendant_node}')\n\n        # Retrieve descendants of the ancestor\n        descendants = set(\n            self.__navigator.get_descendants(ancestor_node, include_self=False)\n        )\n        return descendant_node in descendants\n\n    def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n        \"\"\"Check if two nodes are siblings (i.e., share at least one common parent).\n\n        Parameters\n        ----------\n        node_a : str\n            First node (term ID).\n        node_b : str\n            Second node (term ID).\n\n        Returns:\n        -------\n        bool\n            True if both nodes share at least one parent; False otherwise.\n        \"\"\"\n        # Validate existence\n        lut = self.lookup_tables.get_lut_term_to_index()\n        if node_a not in lut:\n            raise KeyError(f'Unknown term ID: {node_a}')\n        if node_b not in lut:\n            raise KeyError(f'Unknown term ID: {node_b}')\n\n        # Step 1: Get parents for both nodes\n        parents_a = set(\n            self.__navigator.get_parents(node_a, include_self=False)\n        )\n        parents_b = set(\n            self.__navigator.get_parents(node_b, include_self=False)\n        )\n\n        # Step 2: Intersection of parents indicates sibling relationship\n        shared_parents = parents_a.intersection(parents_b)\n\n        # Step 3: Return True if they share any parent\n        return len(shared_parents) &gt; 0\n\n    def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Return the common ancestors of a list of terms.\n\n        Parameters\n        ----------\n        node_ids : List[str]\n            List of starting term IDs.\n        include_self : bool\n            Whether to include the starting nodes themselves in the ancestor sets.\n\n        Returns:\n        -------\n        List[str]\n            List of term IDs that are common ancestors to all input terms.\n        \"\"\"\n        if not node_ids:\n            return []\n\n        # get ancestors for the first node\n        common_ancestors = set(\n            self.__navigator.get_ancestors(node_ids[0], include_self=False)\n        )\n\n        # intersect with ancestors of the rest\n        for term_id in node_ids[1:]:\n            ancestors = set(\n                self.__navigator.get_ancestors(term_id, include_self=False)\n            )\n            common_ancestors.intersection_update(ancestors)\n\n            # early exit if no common ancestor remains\n            if not common_ancestors:\n                return []\n\n        return set(common_ancestors)\n\n    def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; list[str]:\n        \"\"\"Return the lowest common ancestor(s) of a list of terms.\n\n        Lowest = closest to the given terms.\n\n        Parameters\n        ----------\n        node_ids : List[str]\n            List of starting term IDs.\n        include_self : bool\n            Whether to include the starting nodes in ancestor sets.\n\n        Returns:\n        -------\n        List[str]\n            List of term IDs that are the lowest common ancestors.\n        \"\"\"\n\n        if not node_ids:\n            return []\n\n        # Compute ancestors with distances for the first node\n        first_ancestors = dict(\n            self.__navigator.get_ancestors_with_distance(\n                node_ids[0], include_self=False\n            )\n        )\n        common_ancestors = set(first_ancestors.keys())\n\n        # Initialize distances dict for LCA calculation\n        # key: ancestor index, value: max distance from any node\n        lca_distances = dict(first_ancestors.items())\n\n        # Process remaining nodes\n        for term_id in node_ids[1:]:\n            ancestors_with_distance = dict(\n                self.__navigator.get_ancestors_with_distance(\n                    term_id, include_self=False\n                )\n            )\n            ancestors_set = set(ancestors_with_distance.keys())\n            common_ancestors.intersection_update(ancestors_set)\n\n            # Update max distance for each common ancestor\n            lca_distances = {\n                idx: max(lca_distances[idx], ancestors_with_distance[idx])\n                for idx in common_ancestors\n            }\n\n            # Early exit if no common ancestor remains\n            if not common_ancestors:\n                return []\n\n        if not lca_distances:\n            return []\n\n        # Find the minimum of the maximum distances\n        min_distance = min(lca_distances.values())\n\n        # Return ancestor IDs that have this minimum distance\n        lowest_common_indices = [\n            idx for idx, dist in lca_distances.items() if dist == min_distance\n        ]\n        return lowest_common_indices\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.__init__","title":"<code>__init__(navigator, lookup_tables)</code>","text":"<p>Initialize OntologyRelations.</p> <p>Parameters:</p> Name Type Description Default <code>navigator</code> <code>NavigatorOntology</code> <p>The ontology navigator instance.</p> required <code>lookup_tables</code> <code>object</code> <p>Lookup tables for term indices and relationships.</p> required Source code in <code>ontograph/queries/relations.py</code> <pre><code>def __init__(\n    self, navigator: _OntologyNavigator, lookup_tables: object\n) -&gt; None:\n    \"\"\"Initialize OntologyRelations.\n\n    Args:\n        navigator (_OntologyNavigator): The ontology navigator instance.\n        lookup_tables (object): Lookup tables for term indices and relationships.\n    \"\"\"\n    self.__navigator = navigator\n    self.lookup_tables = lookup_tables\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_common_ancestors","title":"<code>get_common_ancestors(node_ids)</code>","text":"<p>Return the common ancestors of a list of terms.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_common_ancestors--parameters","title":"Parameters","text":"<p>node_ids : List[str]     List of starting term IDs. include_self : bool     Whether to include the starting nodes themselves in the ancestor sets.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_common_ancestors--returns","title":"Returns:","text":"<p>List[str]     List of term IDs that are common ancestors to all input terms.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Return the common ancestors of a list of terms.\n\n    Parameters\n    ----------\n    node_ids : List[str]\n        List of starting term IDs.\n    include_self : bool\n        Whether to include the starting nodes themselves in the ancestor sets.\n\n    Returns:\n    -------\n    List[str]\n        List of term IDs that are common ancestors to all input terms.\n    \"\"\"\n    if not node_ids:\n        return []\n\n    # get ancestors for the first node\n    common_ancestors = set(\n        self.__navigator.get_ancestors(node_ids[0], include_self=False)\n    )\n\n    # intersect with ancestors of the rest\n    for term_id in node_ids[1:]:\n        ancestors = set(\n            self.__navigator.get_ancestors(term_id, include_self=False)\n        )\n        common_ancestors.intersection_update(ancestors)\n\n        # early exit if no common ancestor remains\n        if not common_ancestors:\n            return []\n\n    return set(common_ancestors)\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_lowest_common_ancestors","title":"<code>get_lowest_common_ancestors(node_ids)</code>","text":"<p>Return the lowest common ancestor(s) of a list of terms.</p> <p>Lowest = closest to the given terms.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_lowest_common_ancestors--parameters","title":"Parameters","text":"<p>node_ids : List[str]     List of starting term IDs. include_self : bool     Whether to include the starting nodes in ancestor sets.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.get_lowest_common_ancestors--returns","title":"Returns:","text":"<p>List[str]     List of term IDs that are the lowest common ancestors.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; list[str]:\n    \"\"\"Return the lowest common ancestor(s) of a list of terms.\n\n    Lowest = closest to the given terms.\n\n    Parameters\n    ----------\n    node_ids : List[str]\n        List of starting term IDs.\n    include_self : bool\n        Whether to include the starting nodes in ancestor sets.\n\n    Returns:\n    -------\n    List[str]\n        List of term IDs that are the lowest common ancestors.\n    \"\"\"\n\n    if not node_ids:\n        return []\n\n    # Compute ancestors with distances for the first node\n    first_ancestors = dict(\n        self.__navigator.get_ancestors_with_distance(\n            node_ids[0], include_self=False\n        )\n    )\n    common_ancestors = set(first_ancestors.keys())\n\n    # Initialize distances dict for LCA calculation\n    # key: ancestor index, value: max distance from any node\n    lca_distances = dict(first_ancestors.items())\n\n    # Process remaining nodes\n    for term_id in node_ids[1:]:\n        ancestors_with_distance = dict(\n            self.__navigator.get_ancestors_with_distance(\n                term_id, include_self=False\n            )\n        )\n        ancestors_set = set(ancestors_with_distance.keys())\n        common_ancestors.intersection_update(ancestors_set)\n\n        # Update max distance for each common ancestor\n        lca_distances = {\n            idx: max(lca_distances[idx], ancestors_with_distance[idx])\n            for idx in common_ancestors\n        }\n\n        # Early exit if no common ancestor remains\n        if not common_ancestors:\n            return []\n\n    if not lca_distances:\n        return []\n\n    # Find the minimum of the maximum distances\n    min_distance = min(lca_distances.values())\n\n    # Return ancestor IDs that have this minimum distance\n    lowest_common_indices = [\n        idx for idx, dist in lca_distances.items() if dist == min_distance\n    ]\n    return lowest_common_indices\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_ancestor","title":"<code>is_ancestor(ancestor_node, descendant_node)</code>","text":"<p>Check if <code>ancestor_node</code> is an ancestor of <code>descendant_node</code>.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_ancestor--parameters","title":"Parameters","text":"<p>ancestor_node : str     Candidate ancestor term ID. descendant_node : str     Candidate descendant term ID.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_ancestor--returns","title":"Returns:","text":"<p>bool     True if <code>ancestor_node</code> is an ancestor of <code>descendant_node</code>, else False.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n    \"\"\"Check if `ancestor_node` is an ancestor of `descendant_node`.\n\n    Parameters\n    ----------\n    ancestor_node : str\n        Candidate ancestor term ID.\n    descendant_node : str\n        Candidate descendant term ID.\n\n    Returns:\n    -------\n    bool\n        True if `ancestor_node` is an ancestor of `descendant_node`, else False.\n    \"\"\"\n    if descendant_node not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {descendant_node}')\n    if ancestor_node not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {ancestor_node}')\n\n    # Retrieve ancestors of the descendant\n    ancestors = set(\n        self.__navigator.get_ancestors(descendant_node, include_self=False)\n    )\n    return ancestor_node in ancestors\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_descendant","title":"<code>is_descendant(descendant_node, ancestor_node)</code>","text":"<p>Check if <code>descendant_node</code> is a descendant of <code>ancestor_node</code>.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_descendant--parameters","title":"Parameters","text":"<p>descendant_node : str     Candidate descendant term ID. ancestor_node : str     Candidate ancestor term ID.</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_descendant--returns","title":"Returns:","text":"<p>bool     True if <code>descendant_node</code> is a descendant of <code>ancestor_node</code>, else False.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n    \"\"\"Check if `descendant_node` is a descendant of `ancestor_node`.\n\n    Parameters\n    ----------\n    descendant_node : str\n        Candidate descendant term ID.\n    ancestor_node : str\n        Candidate ancestor term ID.\n\n    Returns:\n    -------\n    bool\n        True if `descendant_node` is a descendant of `ancestor_node`, else False.\n    \"\"\"\n    if ancestor_node not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {ancestor_node}')\n    if descendant_node not in self.lookup_tables.get_lut_term_to_index():\n        raise KeyError(f'Unknown term ID: {descendant_node}')\n\n    # Retrieve descendants of the ancestor\n    descendants = set(\n        self.__navigator.get_descendants(ancestor_node, include_self=False)\n    )\n    return descendant_node in descendants\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_sibling","title":"<code>is_sibling(node_a, node_b)</code>","text":"<p>Check if two nodes are siblings (i.e., share at least one common parent).</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_sibling--parameters","title":"Parameters","text":"<p>node_a : str     First node (term ID). node_b : str     Second node (term ID).</p>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsGraphblas.is_sibling--returns","title":"Returns:","text":"<p>bool     True if both nodes share at least one parent; False otherwise.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n    \"\"\"Check if two nodes are siblings (i.e., share at least one common parent).\n\n    Parameters\n    ----------\n    node_a : str\n        First node (term ID).\n    node_b : str\n        Second node (term ID).\n\n    Returns:\n    -------\n    bool\n        True if both nodes share at least one parent; False otherwise.\n    \"\"\"\n    # Validate existence\n    lut = self.lookup_tables.get_lut_term_to_index()\n    if node_a not in lut:\n        raise KeyError(f'Unknown term ID: {node_a}')\n    if node_b not in lut:\n        raise KeyError(f'Unknown term ID: {node_b}')\n\n    # Step 1: Get parents for both nodes\n    parents_a = set(\n        self.__navigator.get_parents(node_a, include_self=False)\n    )\n    parents_b = set(\n        self.__navigator.get_parents(node_b, include_self=False)\n    )\n\n    # Step 2: Intersection of parents indicates sibling relationship\n    shared_parents = parents_a.intersection(parents_b)\n\n    # Step 3: Return True if they share any parent\n    return len(shared_parents) &gt; 0\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology","title":"<code>RelationsOntology</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for querying relationships between ontology terms.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>class RelationsOntology(ABC):\n    \"\"\"Abstract class for querying relationships between ontology terms.\"\"\"\n\n    def __init__(self, navigator: _OntologyNavigator) -&gt; None:\n        self._navigator = navigator\n\n    @abstractmethod\n    def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n        \"\"\"Determines if `ancestor_node` is an ancestor of `descendant_node`.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n        \"\"\"Determines if `descendant_node` is a descendant of `ancestor_node`.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n        \"\"\"Determine if two nodes are siblings (share at least one parent).\"\"\"\n        pass\n\n    @abstractmethod\n    def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Finds the common ancestors of a list of nodes.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Finds the lowest common ancestors among a set of nodes.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology.get_common_ancestors","title":"<code>get_common_ancestors(node_ids)</code>  <code>abstractmethod</code>","text":"<p>Finds the common ancestors of a list of nodes.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>@abstractmethod\ndef get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Finds the common ancestors of a list of nodes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology.get_lowest_common_ancestors","title":"<code>get_lowest_common_ancestors(node_ids)</code>  <code>abstractmethod</code>","text":"<p>Finds the lowest common ancestors among a set of nodes.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>@abstractmethod\ndef get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Finds the lowest common ancestors among a set of nodes.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology.is_ancestor","title":"<code>is_ancestor(ancestor_node, descendant_node)</code>  <code>abstractmethod</code>","text":"<p>Determines if <code>ancestor_node</code> is an ancestor of <code>descendant_node</code>.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>@abstractmethod\ndef is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n    \"\"\"Determines if `ancestor_node` is an ancestor of `descendant_node`.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology.is_descendant","title":"<code>is_descendant(descendant_node, ancestor_node)</code>  <code>abstractmethod</code>","text":"<p>Determines if <code>descendant_node</code> is a descendant of <code>ancestor_node</code>.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>@abstractmethod\ndef is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n    \"\"\"Determines if `descendant_node` is a descendant of `ancestor_node`.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsOntology.is_sibling","title":"<code>is_sibling(node_a, node_b)</code>  <code>abstractmethod</code>","text":"<p>Determine if two nodes are siblings (share at least one parent).</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>@abstractmethod\ndef is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n    \"\"\"Determine if two nodes are siblings (share at least one parent).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto","title":"<code>RelationsPronto</code>","text":"<p>               Bases: <code>RelationsOntology</code></p> <p>Provides methods for querying relationships between ontology terms.</p> <p>Includes ancestor, descendant, sibling checks, and common ancestor computations.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>class RelationsPronto(RelationsOntology):\n    \"\"\"Provides methods for querying relationships between ontology terms.\n\n    Includes ancestor, descendant, sibling checks, and common ancestor computations.\n    \"\"\"\n\n    def __init__(self, navigator: _OntologyNavigator) -&gt; None:\n        \"\"\"Initialize OntologyRelations.\n\n        Args:\n            navigator (_OntologyNavigator): The ontology navigator instance.\n        \"\"\"\n        self.__navigator = navigator\n\n    def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n        \"\"\"Determines if `ancestor_node` is an ancestor of `descendant_node`.\n\n        Args:\n            ancestor_node (str): The ID of the potential ancestor term.\n            descendant_node (str): The ID of the potential descendant term.\n\n        Returns:\n            bool: True if `ancestor_node` is an ancestor of `descendant_node`, False otherwise.\n\n        Raises:\n            Exception: If an unexpected error occurs during ancestor lookup.\n        \"\"\"\n        try:\n            ancestors = self.__navigator.get_ancestors(\n                descendant_node, include_self=False\n            )\n            return ancestor_node in ancestors\n        except Exception as e:\n            logger.error(f'Error checking ancestor relationship: {e}')\n            raise\n\n    def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n        \"\"\"Determines if `descendant_node` is a descendant of `ancestor_node`.\n\n        Args:\n            descendant_node (str): The ID of the potential descendant term.\n            ancestor_node (str): The ID of the potential ancestor term.\n\n        Returns:\n            bool: True if `descendant_node` is a descendant of `ancestor_node`, False otherwise.\n\n        Raises:\n            Exception: If an unexpected error occurs during descendant lookup.\n        \"\"\"\n        try:\n            descendants = self.__navigator.get_descendants(\n                ancestor_node, include_self=False\n            )\n            return descendant_node in descendants\n        except Exception as e:\n            logger.error(f'Error checking descendant relationship: {e}')\n            raise\n\n    def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n        \"\"\"Determine if two nodes are siblings (share at least one parent).\n\n        Siblings are defined as nodes that are not the same and share at least one parent (i.e., their sets of parents intersect).\n\n        Args:\n            node_a (str): The ID of the first node.\n            node_b (str): The ID of the second node.\n\n        Returns:\n            bool: True if the nodes are siblings (not the same node and share at least one parent), False otherwise.\n\n        Raises:\n            KeyError: If either node_a or node_b is not found in the ontology.\n            Exception: If an error occurs during parent lookup.\n        \"\"\"\n        try:\n            parentsA = set(self.__navigator.get_parents(term_id=node_a))\n            parentsB = set(self.__navigator.get_parents(term_id=node_b))\n\n            # Siblings must not be the same node and must share at least one parent\n            return node_a != node_b and bool(parentsA &amp; parentsB)\n        except Exception as e:\n            logger.error(f'Error checking sibling relationship: {e}')\n            raise\n\n    def _get_distance_to_ancestor(\n        self, node: str, ancestor: str\n    ) -&gt; int | float:\n        \"\"\"Calculate the shortest distance from a node to a specified ancestor.\n\n        Args:\n            node (str): The ID of the starting node.\n            ancestor (str): The ID of the ancestor node to find.\n\n        Returns:\n            int: The shortest distance (number of edges) from `node` to `ancestor`.\n            float: Returns float(\"inf\") if no path exists.\n\n        Raises:\n            Exception: If an error occurs during term lookup or traversal.\n        \"\"\"\n        try:\n            term = self.__navigator.get_term(node)\n        except Exception as e:\n            logger.error(f\"Error retrieving term for node '{node}': {e}\")\n            raise\n\n        visited = set()\n        queue = deque([(term, 0)])\n        while queue:\n            try:\n                current, dist = queue.popleft()\n                if current.id == ancestor:\n                    return dist\n                if current.id in visited:\n                    continue\n                visited.add(current.id)\n                for parent in current.superclasses(distance=1, with_self=False):\n                    if parent.id not in visited:\n                        queue.append((parent, dist + 1))\n            except Exception as e:\n                logger.error(f'Error during ancestor traversal: {e}')\n                raise\n        return float('inf')\n\n    def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Finds the common ancestors of a list of nodes.\n\n        Args:\n            node_ids (list[str]): List of node IDs to find common ancestors for.\n\n        Returns:\n            set: Set of common ancestor IDs. Returns an empty set if there are no common ancestors or if input is empty.\n\n        Raises:\n            Exception: If an error occurs during ancestor lookup for any node.\n        \"\"\"\n        if not node_ids:\n            return set()\n\n        ancestor_sets = []\n        try:\n            for node_id in node_ids:\n                try:\n                    ancestors = set(\n                        self.__navigator.get_ancestors(\n                            node_id, include_self=True\n                        )\n                    )\n                    ancestor_sets.append(ancestors)\n                except Exception as e:\n                    logger.error(\n                        f\"Error retrieving ancestors for node '{node_id}': {e}\"\n                    )\n                    raise\n            common_ancestors = set.intersection(*ancestor_sets)\n            logger.debug(f'Common ancestors: {common_ancestors}')\n        except Exception as e:\n            logger.error(f'Error during common ancestor computation: {e}')\n            raise\n\n        return common_ancestors\n\n    def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n        \"\"\"Finds the lowest common ancestors among a set of nodes.\n\n        This method computes the common ancestors for the given node IDs and determines\n        which of these ancestors are the lowest (i.e., have the minimal maximal distance\n        from any of the nodes in the input set).\n\n        Args:\n            node_ids (Iterable[Any]): An iterable of node identifiers for which to find the lowest common ancestors.\n\n        Returns:\n            Set[Any]: A set of node identifiers representing the lowest common ancestors.\n\n        Raises:\n            ValueError: If there are no common ancestors (i.e., the input sequence is empty).\n        \"\"\"\n\n        common_ancestors = self.get_common_ancestors(node_ids)\n\n        # For each common ancestor, calculate its max distance from all nodes\n        distances = {}\n        for ancestor in common_ancestors:\n            max_dist = max(\n                self._get_distance_to_ancestor(node_id, ancestor)\n                for node_id in node_ids\n            )\n            distances[ancestor] = max_dist\n        logger.debug(f'Distances: {distances}')\n\n        try:\n            min_distance = min(distances.values())\n        except ValueError as e:\n            logger.exception(f'Empty sequence: {e}')\n            raise\n\n        lowest_common = {\n            anc for anc, dist in distances.items() if dist == min_distance\n        }\n        return lowest_common\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto-functions","title":"Functions","text":""},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.__init__","title":"<code>__init__(navigator)</code>","text":"<p>Initialize OntologyRelations.</p> <p>Parameters:</p> Name Type Description Default <code>navigator</code> <code>NavigatorOntology</code> <p>The ontology navigator instance.</p> required Source code in <code>ontograph/queries/relations.py</code> <pre><code>def __init__(self, navigator: _OntologyNavigator) -&gt; None:\n    \"\"\"Initialize OntologyRelations.\n\n    Args:\n        navigator (_OntologyNavigator): The ontology navigator instance.\n    \"\"\"\n    self.__navigator = navigator\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.get_common_ancestors","title":"<code>get_common_ancestors(node_ids)</code>","text":"<p>Finds the common ancestors of a list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>list[str]</code> <p>List of node IDs to find common ancestors for.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>Set of common ancestor IDs. Returns an empty set if there are no common ancestors or if input is empty.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during ancestor lookup for any node.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def get_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Finds the common ancestors of a list of nodes.\n\n    Args:\n        node_ids (list[str]): List of node IDs to find common ancestors for.\n\n    Returns:\n        set: Set of common ancestor IDs. Returns an empty set if there are no common ancestors or if input is empty.\n\n    Raises:\n        Exception: If an error occurs during ancestor lookup for any node.\n    \"\"\"\n    if not node_ids:\n        return set()\n\n    ancestor_sets = []\n    try:\n        for node_id in node_ids:\n            try:\n                ancestors = set(\n                    self.__navigator.get_ancestors(\n                        node_id, include_self=True\n                    )\n                )\n                ancestor_sets.append(ancestors)\n            except Exception as e:\n                logger.error(\n                    f\"Error retrieving ancestors for node '{node_id}': {e}\"\n                )\n                raise\n        common_ancestors = set.intersection(*ancestor_sets)\n        logger.debug(f'Common ancestors: {common_ancestors}')\n    except Exception as e:\n        logger.error(f'Error during common ancestor computation: {e}')\n        raise\n\n    return common_ancestors\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.get_lowest_common_ancestors","title":"<code>get_lowest_common_ancestors(node_ids)</code>","text":"<p>Finds the lowest common ancestors among a set of nodes.</p> <p>This method computes the common ancestors for the given node IDs and determines which of these ancestors are the lowest (i.e., have the minimal maximal distance from any of the nodes in the input set).</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>Iterable[Any]</code> <p>An iterable of node identifiers for which to find the lowest common ancestors.</p> required <p>Returns:</p> Type Description <code>set</code> <p>Set[Any]: A set of node identifiers representing the lowest common ancestors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are no common ancestors (i.e., the input sequence is empty).</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def get_lowest_common_ancestors(self, node_ids: list[str]) -&gt; set:\n    \"\"\"Finds the lowest common ancestors among a set of nodes.\n\n    This method computes the common ancestors for the given node IDs and determines\n    which of these ancestors are the lowest (i.e., have the minimal maximal distance\n    from any of the nodes in the input set).\n\n    Args:\n        node_ids (Iterable[Any]): An iterable of node identifiers for which to find the lowest common ancestors.\n\n    Returns:\n        Set[Any]: A set of node identifiers representing the lowest common ancestors.\n\n    Raises:\n        ValueError: If there are no common ancestors (i.e., the input sequence is empty).\n    \"\"\"\n\n    common_ancestors = self.get_common_ancestors(node_ids)\n\n    # For each common ancestor, calculate its max distance from all nodes\n    distances = {}\n    for ancestor in common_ancestors:\n        max_dist = max(\n            self._get_distance_to_ancestor(node_id, ancestor)\n            for node_id in node_ids\n        )\n        distances[ancestor] = max_dist\n    logger.debug(f'Distances: {distances}')\n\n    try:\n        min_distance = min(distances.values())\n    except ValueError as e:\n        logger.exception(f'Empty sequence: {e}')\n        raise\n\n    lowest_common = {\n        anc for anc, dist in distances.items() if dist == min_distance\n    }\n    return lowest_common\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.is_ancestor","title":"<code>is_ancestor(ancestor_node, descendant_node)</code>","text":"<p>Determines if <code>ancestor_node</code> is an ancestor of <code>descendant_node</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ancestor_node</code> <code>str</code> <p>The ID of the potential ancestor term.</p> required <code>descendant_node</code> <code>str</code> <p>The ID of the potential descendant term.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>ancestor_node</code> is an ancestor of <code>descendant_node</code>, False otherwise.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an unexpected error occurs during ancestor lookup.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_ancestor(self, ancestor_node: str, descendant_node: str) -&gt; bool:\n    \"\"\"Determines if `ancestor_node` is an ancestor of `descendant_node`.\n\n    Args:\n        ancestor_node (str): The ID of the potential ancestor term.\n        descendant_node (str): The ID of the potential descendant term.\n\n    Returns:\n        bool: True if `ancestor_node` is an ancestor of `descendant_node`, False otherwise.\n\n    Raises:\n        Exception: If an unexpected error occurs during ancestor lookup.\n    \"\"\"\n    try:\n        ancestors = self.__navigator.get_ancestors(\n            descendant_node, include_self=False\n        )\n        return ancestor_node in ancestors\n    except Exception as e:\n        logger.error(f'Error checking ancestor relationship: {e}')\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.is_descendant","title":"<code>is_descendant(descendant_node, ancestor_node)</code>","text":"<p>Determines if <code>descendant_node</code> is a descendant of <code>ancestor_node</code>.</p> <p>Parameters:</p> Name Type Description Default <code>descendant_node</code> <code>str</code> <p>The ID of the potential descendant term.</p> required <code>ancestor_node</code> <code>str</code> <p>The ID of the potential ancestor term.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>descendant_node</code> is a descendant of <code>ancestor_node</code>, False otherwise.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an unexpected error occurs during descendant lookup.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_descendant(self, descendant_node: str, ancestor_node: str) -&gt; bool:\n    \"\"\"Determines if `descendant_node` is a descendant of `ancestor_node`.\n\n    Args:\n        descendant_node (str): The ID of the potential descendant term.\n        ancestor_node (str): The ID of the potential ancestor term.\n\n    Returns:\n        bool: True if `descendant_node` is a descendant of `ancestor_node`, False otherwise.\n\n    Raises:\n        Exception: If an unexpected error occurs during descendant lookup.\n    \"\"\"\n    try:\n        descendants = self.__navigator.get_descendants(\n            ancestor_node, include_self=False\n        )\n        return descendant_node in descendants\n    except Exception as e:\n        logger.error(f'Error checking descendant relationship: {e}')\n        raise\n</code></pre>"},{"location":"reference/source/ontograph/queries/relations/#ontograph.queries.relations.RelationsPronto.is_sibling","title":"<code>is_sibling(node_a, node_b)</code>","text":"<p>Determine if two nodes are siblings (share at least one parent).</p> <p>Siblings are defined as nodes that are not the same and share at least one parent (i.e., their sets of parents intersect).</p> <p>Parameters:</p> Name Type Description Default <code>node_a</code> <code>str</code> <p>The ID of the first node.</p> required <code>node_b</code> <code>str</code> <p>The ID of the second node.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the nodes are siblings (not the same node and share at least one parent), False otherwise.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either node_a or node_b is not found in the ontology.</p> <code>Exception</code> <p>If an error occurs during parent lookup.</p> Source code in <code>ontograph/queries/relations.py</code> <pre><code>def is_sibling(self, node_a: str, node_b: str) -&gt; bool:\n    \"\"\"Determine if two nodes are siblings (share at least one parent).\n\n    Siblings are defined as nodes that are not the same and share at least one parent (i.e., their sets of parents intersect).\n\n    Args:\n        node_a (str): The ID of the first node.\n        node_b (str): The ID of the second node.\n\n    Returns:\n        bool: True if the nodes are siblings (not the same node and share at least one parent), False otherwise.\n\n    Raises:\n        KeyError: If either node_a or node_b is not found in the ontology.\n        Exception: If an error occurs during parent lookup.\n    \"\"\"\n    try:\n        parentsA = set(self.__navigator.get_parents(term_id=node_a))\n        parentsB = set(self.__navigator.get_parents(term_id=node_b))\n\n        # Siblings must not be the same node and must share at least one parent\n        return node_a != node_b and bool(parentsA &amp; parentsB)\n    except Exception as e:\n        logger.error(f'Error checking sibling relationship: {e}')\n        raise\n</code></pre>"}]}